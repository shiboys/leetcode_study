### 贪心算法
**贪心算法**（英语：greedy algorithm）,又称贪婪算法，是一种在每一步选择中都采取在当前状态下最好或最优(即最有利)的选择，从而希望导致结果是最好或最优的算法。比如在 旅行推销员问题中(https://zh.wikipedia.org/wiki/%E6%97%85%E8%A1%8C%E6%8E%A8%E9%94%80%E5%91%98%E9%97%AE%E9%A2%98)，如果旅行员每次都选择最近的城市，那这就是一种贪心算法。

贪心算法在最优子结构的问题中尤为有效。最优子结构的意思是局部最优解能决定全局最优解。简单地说，问题能够分解成子问题来解决，子问题的最优解能递推出最终问题的最优解。

贪心算法与动态规划的同步在于他对每个子问题的解决方案都做出选择，不能回退。动态规划则会爆粗以前的运算结果，并根据以前的结果对当前进行旋转，又回退功能。

贪心算法可以解决一些最优化的问题，比如，求图中的最小生成树，求哈夫曼编码。。。对于其他问题，贪心算法一般不能得到我们所要求的答案。一旦一个问题可以通过贪心法来解决，那么贪心法一般是解决这个问题的最好办法

#### 贪心算法之区间调度问题

##### 问题概述

leetcode 435. 无重叠区间

给定一个区间的集合 intervals ，其中 intervals[i] = [starti, endi] 。返回 需要移除区间的最小数量，使剩余区间互不重叠 。

示例 1:

输入: intervals = [[1,2],[2,3],[3,4],[1,3]]
输出: 1
解释: 移除 [1,3] 后，剩下的区间没有重叠。

这个问题，在生活中应用广泛，比如说您今天有好几个活动，每个活动都可以用区间 `[start, end]` 表示开始和结束时间，请你你今天**最多能参加几个活动那**？显然你一个人不能同时参加两个活动，索引说这个问题就是求**这些时间区间的最大不相交子集**。

言归正传，本题目是要解决一个很精单的贪心算法问题 Interval Scheduling (区间调度问题)，给你很多形如 `[start,end]` 的闭区间，请你设计一个算法，**算出这些区间中最多有几个互不相交的区间**。

```java
int  intervalSchedule(int[]][] intvs);
```

举个栗子，`intvs=[[1,3],[2,4],[3,6]]` ，这些区间最多有 2 个区间互不相交，即 `[1,3], [3,6] `， 你的算法应该返回 2。注意边界相同并不相交。


##### 贪心解法

这道题的思路也很简单，可以分为 3 步：
1、从区间集合 `intvs` 选择一个区间 `x`, 这个`x`是当前所有区间中**结束最早的**(`end` 最小).
2、把所有与 `x` 区间相交的区间从区间集合 `intvs` 中删除
3、重复步骤 1 和 2，直到 `intvs` 为空为止。上一次选出的 x 就是最大不相交子集

把这个思路实现成算法的话，可以按照每个区间的 end 数值升序排序，因为这样处理之后实现步骤 1 和 步骤2 都方便很多，如下图所示：

![贪心区间调度](../dynamic_programming/imgs/speed_ag2.png)

现在来实现算法，对于步骤 1 ，由于我们是预先按照 end 排了序，所有选择 x 是很容易的。关键在于，如何去除与 x 相交的区间，选择下一轮循环的 x 那？

**由于我们实现进行了排序**，不难发现所有与 x 相交的区间必然会与 x 的 end 相交；如果一个区间不想与 x 的 end 相交，它的 start 必须大于或等于 x 的 end，参考上图，

基于以上思想，代码实现如下：

```java
int intervalScheduleCount(int[][] intervals) {
        // 先按照 end 进行排序
        Arrays.sort(intervals,(a,b)->{
            return a[1]-b[1];
        });
        
        // 至少一个不想交区间
        int xcount =1;
        int xend = intervals[0][1];
        for(int i=1;i<intervals.length;i++) {
            int xstart = intervals[i][0];
            if(xstart>=xend) {
                xcount++;
                // 更新 xend
                xend =  intervals[i][1];
            }
        }
        return xcount;
    }
```

再说说 leetcode 452 题，「用最少的箭头射爆气球」

有一些球形气球贴在一堵用 XY 平面表示的墙面上。墙面上的气球记录在整数数组 points ，其中points[i] = [xstart, xend] 表示水平直径在 xstart 和 xend之间的气球。你不知道气球的确切 y 坐标。

一支弓箭可以沿着 x 轴从不同点 完全垂直 地射出。在坐标 x 处射出一支箭，若有一个气球的直径的开始和结束坐标为 xstart，xend， 且满足  xstart ≤ x ≤ xend，则该气球会被 引爆 。可以射出的弓箭的数量 没有限制 。 弓箭一旦被射出之后，可以无限地前进（在坐标上是从下到上，在二维数组矩阵中是从上到下直到底）。

给你一个数组 points ，返回引爆所有气球所必须射出的 最小 弓箭数 。

示例 1：

输入：points = [[10,16],[2,8],[1,6],[7,12]]
输出：2
解释：气球可以用2支箭来爆破:
-在x = 6处射出箭，击破气球[2,8]和[1,6]。
-在x = 11处发射箭，击破气球[10,16]和[7,12]。

其实稍微思考一下，这个问题和区间调度算法一模一样！如果最多有 `n` 个不重叠的区间，那么就至少需要 `n` 个箭头穿透所有区间

![贪心区间调度](../dynamic_programming/imgs/speed_ag3.png)

只有一个点不一样，在 `intervalSchedule` 算法中，如果两个区间的边界触碰，不算重叠；而按照这个题目的描述，箭头如果碰到气球的编辑气球也会爆炸，所以说相当于区间的边界碰触也算重叠：

![贪心区间调度](../dynamic_programming/imgs/speed_ag4.png)

所以只需要将之前的算法稍微修改，就是这个题目的答案：

```java
int intervalScheduleCount(int[][] intervals) {
        // 先按照 end 进行排序
        Arrays.sort(intervals,(a,b)->{
            return a[1]-b[1];
        });
        
        // 至少一个不想交区间
        int xcount =1;
        int xend = intervals[0][1];
        for(int i=1;i<intervals.length;i++) {
            int xstart = intervals[i][0];
            // 必须大于，才算一个新的区间，因此这里的 >= 改为 >
            if(xstart>xend) {
                xcount++;
                xend =  intervals[i][1];
            }
        }
        return xcount;
    }
```

#### 134. 加油站

在一条环路上有 n 个加油站，其中第 i 个加油站有汽油 gas[i] 升。

你有一辆油箱容量无限的的汽车，从第 i 个加油站开往第 i+1 个加油站需要消耗汽油 cost[i] 升。你从其中的一个加油站出发，开始时油箱为空。

给定两个整数数组 gas 和 cost ，如果你可以按顺序绕环路行驶一周，则返回出发时加油站的编号，否则返回 -1 。如果存在解，则 保证 它是 唯一 的。

示例 1:

输入: gas = [1,2,3,4,5], cost = [3,4,5,1,2]
输出: 3
解释:
从 3 号加油站(索引为 3 处)出发，可获得 4 升汽油。此时油箱有 = 0 + 4 = 4 升汽油
开往 4 号加油站，此时油箱有 4 - 1 + 5 = 8 升汽油
开往 0 号加油站，此时油箱有 8 - 2 + 1 = 7 升汽油
开往 1 号加油站，此时油箱有 7 - 3 + 2 = 6 升汽油
开往 2 号加油站，此时油箱有 6 - 4 + 3 = 5 升汽油
开往 3 号加油站，你需要消耗 5 升汽油，正好足够你返回到 3 号加油站。
因此，3 可为起始索引

题目不难理解，就是每到一个加油站 i，你可以加 gas[i] 升的油，但离开站点i 到下一个 i+1 站点，则需要消耗 cost[i] 升油，问你从那个站点出发，可以兜一圈回来。

要说暴力解法，肯定很容易想到，用一个 for 循环遍历所有站点，假设为 i 为起点，然后再套一层 for 循环，判断一下是否能够转一圈回到 i 起点。

```java
int n = gas.length;
for (int start = 0; start < n; start++) {
    for (int step = 0; step < n; step++) {
        int i = (start + step) % n;
        tank += gas[i];
        tank -= cost[i];
        // 判断油箱中的油是否耗尽
    }
}
```

很明显，时间复杂度是 O(N^2), 这么简单粗暴的解法一定不是最优的，我们视图分析一下是否有优化的余地。

暴力解法是否有重复计算的部分？我们是否可以抽象出「状态」，是否对同一个「状态」重复计算了多次？

通过观察，我们发现，变化的量有两个，分别是「起点」和「当前的邮箱的油量」，但这两个状态的组合下去肯定有不下O(N^2) 中，显然没有什么优化空间
（想象你下，你在二环开车，你分别从每个加油站作为起点出发）

**所以我们不能通过简单的剪枝来优化暴力解法的效率，而是需要发现一些隐藏较深的规律，从而减少一些冗余的计算**

下面我们介绍两种巧妙的方法来解这道题，分别是数学图像解法和贪心解法。
#####
