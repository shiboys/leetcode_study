动态规划章节

leecode 115 题，不同的子序列
https://leetcode.cn/problems/distinct-subsequences/
给你输入一个字符串 s 和一个字符串 t，请你计算在 s 的子序列中 t 出现的次数。比如题目给的例子，输入 s = "babgbag", t = "bag"，算法返回 5

### 一、动态规划解法

动态规划的核心思想是数学归纳法。数学归纳法的思路比价简单，比如我们想证明一个数学结论，那么我们先假设这个结论在 k < n 的时候成立，然后根据这个假设，想办法推导证明出 k=n 的时候此结论依然成立。
如果能够这么出来，说明这个结论对于 k 等于任何值都成立

#### 最长递增子序列
##### 最长子序列查找——二分法
这个解法的时间复杂度为 `O(NlogN)`,但是说实话，正常人更不想不到这种解法(通过下面的纸牌游戏解说可能玩过这类游戏的人可以想出来)。所以我们了解一下就好，正常情况下能够给出动态规划解法就已经很不错了。
根据题目的意思，很难想象这个问题竟然能跟二分法车上关系。其实最长递增西序列和一种叫做 patience game 的纸牌游戏有关，甚至有一种排序方法就叫做 patience sorting(耐心排队)。
为了简单起见，后文跳过所有的数学证明，通过一个简化的例子来理解下算法的思路
首先，给你一副扑克牌，我们像数组遍历一样从左到右一张一张处理这些扑克牌，最终把这些牌分成若干堆。
![扑克牌](imgs/poker3.jpeg)
处理这些扑克牌要遵循一下规则：
只能把点数小的牌压到点数比它大的牌上；如果当前牌点数比较大，没有可用防止的堆，则新建一个堆，把这张牌放进去；如果当前牌有多个堆可以选择，则选择最左边的那个堆放置。

比如说上述扑克牌最终会被分成 5 堆(我们认为纸牌 A 的牌面是最大的，纸牌 2 的牌面是最小的)。
为什么遇到多个可选择的时候要放到最左边的堆上那？因为这样可以保证堆顶的牌有序（2,4,7,8，Q), 证明略。
按照上述规则执行，可以算出最长递增子序列，**<font color='red'>牌的堆数就是子序列的长度</font>**，证明略
我们只需要把处理扑克牌的过程边写出来即可。每次处理一张扑克牌不是要找一个合适的堆顶来存放吗？牌的堆顶不是有序吗？这就能用到二分法查找了：用二分查找搜索牌应放置的位置。
最终的最序列为 [3,5,7,8,12] 如下图所示
![扑克牌摆法](./imgs/poker4.jpeg)

#### 俄罗斯信封解题分析
这道题目其实是最长子序列的一个变种，因为每次合法的嵌套是大的套小的，相当于在二维平明中找一个最长递增的子序列，其长度就是就是最多能签到的信封个数。

前面说的标准的 LIS 算法只能在一维数组中寻找最长子序列，而我们的信封是由(w,h) 这样的二维数组对形式表示的，如何把 LIS 算法云涌过来那？
我们也许会想到，通过 w*h 的方式计算面积，然后对面积进行标准的 LIS 算法。但是稍加思考就会发现这样不行，比如 1*10 大于 3*3 ，但是这显然无法实现两个信封相互嵌套
这道题的解法比较巧妙：
先对宽度 `w` 按升序排列，如果遇到 `w` 相同的，则按照高度 `h` 降序排列；之后把所有的 `h` 作为一个数组，在这个数组上计算 LIS 的长度就是答案
接下来上图来帮助理解下

![俄罗斯套娃信封](./imgs/russia_envelop1.jpg)

然后在 `h` 寻找最长递增子序列，这个子序列就是最优的嵌套方案
![俄罗斯套娃信封](./imgs/russia_envelop2.jpg)

**为什么这就可以找到相互嵌套的信封序列那？** 稍微思考一下就明白了
首先，对宽度`w`从小到大排序，确保了`w`这个维度可以相互嵌套，所以我们只需要专注高度`h`这个维度就可以相互嵌套即可。
其次，两个`w`相同的信封不能相互包含，所以对于宽度`w`相同的信封，对高度`h` 进行降序排列保证二维 LIS 中不存在多个 `w` 相同的信息(因为题目说了长宽相同也无法嵌套)。

#### 编辑距离部分
设两个字符串分别为`rad` 和 `apple`，为了把 s1 变成 s2，算法会是这样进行的：
![编辑距离示例1](./imgs/edit.gif)
![编辑距离示例2](./imgs/edit1.png)

根据上的 gif，我们发现操作不只有三个，其实还有第四个，就是什么都不做 (skip)。比如 s1[i]==s2[j] 的情况，还有一个很容易处理的情况，就是 j 走完了 s2 后，如果 `i` 还没走完 `s1` ，那么只能用删除将 s1 缩短为 s2。类似的，如果 i 走完了 s1 时 j 还没走完 s2，那就只能用插入操作把 s2 剩下的字符全部插入 s1，这两种情况都算是算法的 basecase

伪代码大概如下：
```python
if s1[i] == s2[j]:
    啥都不做(skip)
    i,j 同时向前移动一步
    dp(s1,i-1,s2,j-1)
else:
    三选一：
        插入(insert)
        删除(delete)
        替换(replace)
```
子序列的问题在 sub sequence 子包中

#### 排列组合的 2 种视角

1、P(n,k)(有的书称为 `A(n,k)`) 表示从 n 个不同的元素中拿出 k 个元素的排列 (Permutation/Arrangement); `C(n,k)` 表示从 n 个不同的元素中拿出 k 个元素的组合 (Combination) 总数。
2、「排列」与「组合」的主要区别在于是否考虑顺序的差异
3、排列和组合的总数计算公式如下
![排列组合公式](./imgs/math_arrangement_combinaion.png)

##### 公式推导过程

###### 公式推导1
Q1:有从1到9共计9个号码球，请问，可以组成多少个三位数？

A1:123和213是两个不同的排列数。即对排列顺序有要求的，既属于“排列P”计算范畴。

上问题中，任何一个号码只能用一次，显然不会出现988,997之类的组合，我们可以这么看，百位数有9种可能，十位数则应该有9-1种可能，个位数则应该只有9-1-1种可能，最终共有9*8*7个三位数。计算公式＝P(3,9)＝9*8*7,(从9倒数3个的乘积）

Q2:有从1到9共计9个号码球，请问，如果三个一组，代表“三国联盟”，可以组合成多少个“三国联盟”？

A2:213组合和312组合，代表同一个组合，只要有三个号码球在一起即可。即不要求顺序的，属于“组合C”计算范畴。

上问题中，将所有的包括排列数的个数去除掉属于重复的个数即为最终组合数C(3,9)=9*8*7/3*2*1

重复的个数为什么是 3*2*1，因为 3 个数最大可以组成 3! 个不同排列，在组合的情况下，就是 1 个，因此组合的最终结果是 9*8*7/3*2*1

###### 公式推导2
排列组合问题的各种变体都可以通过「球盒模型」，P(n,k) 就可以抽象成下面这个场景：
![排列组合推导2图片1](./imgs/arrange_pc_7.png)
即，将 `n` 个标记了不同序列号的球（标记号码是为了体现顺序的差异），放入 `k` 个标记了不同序号的盒子中( 其中 `n>=k`, 每个盒子最终都装有恰好一个球)，共有 `P(n,k)` 中不同的方法。
现在你来，往盒子里面访求，你怎么放？其实有 2 中视角。
**首先，你可以站在盒子的视角**，每个盒子必然要选择一个球。
这样，第一个盒子可以选择 `n` 个球中的任意一个，然后你需要让剩下 `k-1` 个盒子在 `n-1` 个球中选择 (第一个例子符合该视角的，百位数可以在 1-9 中选择任意一个数字)
![排列组合推导2图片2](./imgs/arrange_pc_8.png)
**另外，你也可以站在球的角度**，因为并不是每个球都会被装进盒子，所以球的视角分两种情况：
1、第一个球可以不装进任何一个盒子，这样的话你就需要将剩下的 `n-1` 个球放入 `k` 个盒子。
2、第一个球可以装进 `k` 个盒子的任意一个，这样的话，你就需要将剩下的 `n-1` 个球放入 `k-1` 个盒子

综合上述两种情况，可以得到：
![排列组合推导2图片3](./imgs/arrange_pc_9.png)

你看，两种视角得到两个不同的递归模式，但是这两个递归模式解开的结果都是我们熟知的阶乘形式：
![阶乘模式2](./imgs/arrange_pc_math1.png)

至于如何递归，涉及的数学知识内容比较多，这里就不深入探讨了。
当然，以上只是纯数学的推导，P(n,k)的计算那结果也仅仅是一个数字，所以以上两种视角从数学来讲没什么差异，但是从编程的角度来看，如果让你计算出来所有的排列结果，那么这两种穷举思路的代码实现可能会产生性能上的差异，因为有的穷举思路会使用额外的 for 循环来拖慢效率。

因此上述公式满足 P(n,k)=n!/(n-k)!；C(n,k) = P(n,k)/k! = n!/(k!*(n-k)!)

#### 动态规划&排列组合的算法复杂度计算
 M，N 分别表示 s,t 的长度
```
带备忘录的动态规划算法的时间复杂度
=子问题的个数 x 函数本身的时间复杂度
=「状态」的个数 x 函数本身的时间复杂度
= O(MN) * O(M)
= O(N*M^2)
```
当然，因为 for 循环的复杂度并不总是 O(M) 且总问题个数肯定小于 O(MN)(s.length()-i<t.length-j return 0 这时候就不再遍历了，因此总问题个数达不到 O(MN))，所以这是复杂度的粗略上界。
这个上限说明这个算法的复杂度还是有些偏高，主要高在哪里那？对「状态」的穷举已经有 memo 备忘录优化，所以 O(MN)的复杂度是必不可少的，关键的问题处在 dp 函数中的 for 循环。
是否可以优化掉 dp 函数中的 for 循环那？可以的，这就需要另一种视角来解决这个问题。

##### 视角2，站在 `s` 的角度进行穷举

我们的原问题是计算 s[0...] 中的所有子序列中 t[0..] 的出现次数，可以先看看 `s[0]` 是否能匹配 `t[0]`, 如果不匹配，那没得说，原问题就转化为计算 `s[1..]` 的所有子序列中 `t[0..]` 出现的次数；

但是如果 `s[0] ` 可以匹配 `t[0]`, 这两种情况是累加的关系：
1、让 s[0] 匹配 t[0], 那么原问题转化为 s[1..] 的所有子序列中计算 t[1..] 出现的次数
2、不让 s[0] 匹配 t[0], 那么原问题就转化为 s[1..] 中的所有子序列中计算 t[0..] 出现的次数

为啥明明 s[0] 可以匹配 t[0], 还不让它俩匹配那？主要是为了给 s[0] 之后的元素匹配的机会，比如 `s="aab", t="ab"`，就有两种匹配方式 `a_b` 和 `_ab`

把以上思路写成状态转移方程：
```java
// 定义：s[i..] 的子序列中 t[j..] 出现的次数为 dp(s,i,t,j)
int dp(String s,int i,String t,int j) {
    if (s[i] == t[j]) {
        // 匹配，两种情况，累加关系
        return dp(s,i+1,t,j+1) + dp(s,i+1,t,j);
    } else {
        // 不匹配，在 s[i+1..] 的子序列中计算 t[j..] 的出现次数
        return dp(s,i+1,t,j);
    }
}
```
根据以上思路，可以写出 实现函数来

#### 不同的子序列 dp 数组实现
数组实现法，参考下图
![不同的子序列循环实现图解](./imgs/distinct_sub_sequence_dp_array.png)
当 S[j] == T[i] , dp[i][j] = dp[i-1][j-1] + dp[i][j-1];

当 S[j] != T[i] , dp[i][j] = dp[i][j-1]


### 动态规划和回溯算法实现 word Break

回溯法即便我们如何优化，总的时间复杂度依然是指数级的 O(2^N * N^2),是无法通过所有测试用例
那么问题出在哪那？

比如输入 `wordDict = ["a","aa"], s="aaab"`, 算法无法找到一个可行的组合，所以一定会遍历整棵回溯树，但我们要注意里面存在重复的情况。重复情况极端情况下会消耗大量的时间。

**如何消除荣誉计算那？这里要稍微变一下思维模式，用「分解问题」的思维模式来考虑这道题**

我们刚才以排列组合的方式来思考这个问题，现在我们换一种视角，思考一下能否把问题分解成规模更小，结构相同的子问题，然后通过子问题的结果计算原问题的结果(dp 函数不就是干这个的吗)？

对于输入的字符串 `s`, 如果我们能够从单词列表 `wordDict` 中找到一个单词匹配 `s` 的前缀 `s[0..k]`, 那么只要我能拼出 `s[k+1]`, 就一定能拼出整个 `s` 。换句话说，我把规模较大的原问题 `workBreak(s[0..])` 分解成了规模较小的子问题 `wordBreak(s[k+1..])`, 然后通过子问题的求解反推出原问题的解。
有了这个思路就可以定义一个 `dp` 函数, 并给出该函数的定义：
```java
// 定义：返回 s[i..] 能否被拼出
int dp(String s,int i);

// 计算整个 s 是否能够被拼出，调用 dp(s,0)
```
有了这个函数定义，我们就可以把刚才的逻辑大致翻译成伪代码：

```java
HashSet<String> wordDict

// 定义：返回 s[i..] 能否被拼出
int dp(String s,int i) {
    // base case, s[i..] 时空串或者遍历到 s 的结尾
    if(i==s.length) {
        return  true;
    }

    for (int k=1;i+k < s.length(); k++) {
        if wordDict 中存在 s[i..i+k] {
            // 只要 s[i+len..] 能够被拼出，s[i..] 就能被整体拼出
            if(dp(s, i+k)) {
                return true;
            }
        }
    }
    // 所有单词都尝试过，没有办法拼出整个 s
    return false
}
```
_______________________
### 动态规划之最长回文子序列

首先子序列本身想想对于子串，子数组更困难一些，因为前者是不连续的序列，而后者是连续的，你就算穷举你都不一定会，更别说求解先关的算法问题了。

而且，子序列问题很可能设计到两个字符串，比如接下来的《最长公共子序列》，如果没有一定的处理经验，真的不容易想出来。所以本章节就来扒一扒子序列问题的套路，使其就有两种模板，相关问题只要往这两种思路上想，十拿九稳。

一般来说，这类问题都是让我们求一个**最长子序列**，因为最短子序列就一个字符嘛，没啥可问的。一旦涉及到子序列和最值，那几乎可以肯定，**考察的是动态规划技巧，时间复杂度一般都是 O(n^2)**。

原因很简单，你想想一个字符串，它的自徐磊能有所少中可能？起码是指数级的，这种情况下，不用动态规划技巧，还想怎么着？

既然要用动态规划，那就要定义 dp 数组，找找状态关系。我们说的两种思路模板，就是 `dp` 数组的定义思路。不同的问题可能需要不同的 `dp` 数组定义来解决。


#### 一、两种思路
_______________
##### 1、第一种思路模板是一个一维的 `dp` 数组:
```java
int n = array.length;
int[] dp = new int[n];

for(int i=1; i<n; i++) {
    for (j=0;j<i;j++) {
        dp[i] = 最值(dp[i],dp[j] + ...)
    }
}
```

比如我们 之前的 《最长递增子序列》和《最大子数组和》都是这个思路。在这个思路中 `dp` 数组的定义是：
**在子数组 arr[0..i] 中，以 arr[i] 结尾的子序列的长度是 `dp[i]`**。

为啥最长递增子序列需要这种思路那？前文说的很清楚了，因为这样符合归纳法，可以找到状态转移的关系，这里就不具体展开了。

##### 2、第二种思路模板就是一个二维的 `dp` 数组

```java
int n = arr.length;
int[][] dp = new int[n][n];

for (int i=0;i<n;i++) {
    for(int j=0;j<n;j++) {
        if(arr[i] = arr[j]) 
            dp[i][j]=dp[i][j] + ...
        else
            dp[i][j] = 最值(...)
    }
}
```

这种思路运用的更多一些，尤其是涉及两个字符串/数组的子序列时，比如之前的《编辑距离》和接下来的《最长公共子序列》；这种思路也可以用于只设计一个字符串/数组的情景，比如本文讲的回文子序列问题。

**2.1 涉及两个字符串/数组的场景**，`dp` 数组的定义如下
**在子数组 `arr[0..i]` 和子数组 `arr2[0..j]` 中，我们要求的子序列长度为 dp[i][j]**。

**2.2 只涉及一个字符串/数组的场景**, `dp` 数组的定义如下：
在子数组 `array[i..j]` 中, 我们要求的子序列的长度为 `dp[i][j]`。

下面按就看看最长回文子序列问题，详解一下第二种情况下如何使用动态规划。

#### 二、最长回文子序列

之前解决了 《最长回文子串》的问题（在 firstMac 项目的 com.swj.ics.dataStructure.strings.Palindrome 中，本次也会重新求解），这次提升难度，leetcode 第 516 题，求最长回文子序列的长度：

输入一个字符串 s ，请你找出 s 中的最长回文子序列的长度，函数签名如下：
```java
int longestPalinddromeSubseq(String s);
```
比如说输入 `s=aecda` ,算法返回 3 ，因为最长的回文子序列是 `"aca"`, 长度为 3。
我们对 dp 数组的定义是：**在子串 `s[i..j]` 中，最长回文子序列的长度为 `dp[i][j]`。一定要记住这个定义才能理解算法。

为啥这个问题要定义成二维的 dp 数组那？在 《最长递增子序列》提到，找状态转移需要归纳思维，说白了就是如何从已知的结果推导出未知的部分。二折页定义能够进行归纳，容易发现状态转移关系。

具体来说，如果我们想求出 `dp[i][j]`, 假设你知道子问题 `dp[i+1][j-1` 的结果 (`s[i+1..j-1]`中最长回文子序列的长度)，你是否能想办法算出 `dp[i][j]` 的值(`s[i..j]`中，最长回文子序列的长度)那？

![最长回文子序列dp图解1](./imgs/PalindromeSubseq1.png)

可以！这取决于 `s[i]` 和 `s[j]` 的字符：
**如果它俩相等**，那么它俩加上 `s[i+1..j-1]`中的最长回文子序列就是 `s[i..j]` 的最长回文子序列
![最长回文子序列dp图解2](./imgs/PalindromeSubseq2.png)

**如果它俩不相等**，说明它俩**不可能同时**出现在`s[i..j]` 的最长回文中，那么把它俩分别加入 `s[i+1..j-1]` 中，看看哪个字符串产生的回文子序列更长即可：
![最长回文子序列dp图解3](./imgs/PalindromeSubseq3.png)

以上这两种情况写成代码就是这样的 
```java
if (s[i] == s[j]) {
    // 它俩一定出现在最长回文子序列中
    dp[i][j]=dp[i+1][j-1]+2;
} else {
    // s[i+1..j] 和 s[i..j-1] 谁的回文子序列更长？
    dp[i][j]=max(dp[i+1][j],dp[i][j-1])
}
```
至此，状态转移方程就写出来了，根据 dp 数组的dingy9i，我们要求的是 `dp[0][n-1]`, 也是整个 `s` 的最长回文子序列长度。

#### 三、代码实现

首先明确一个base case，如果只有一个字符，显然最长回文子序列长度是 1，也就是 `dp[i][j]=1(i==j)`。
因为 i 肯定小于等于 j，所以对于哪些 i>j 的位置，根本不存在真美子序列，应该初始化为 0。
另外，看看刚才写的状态转移方程，相求 `dp[i][j]` 需要知道 `dp[i+1][j-1]`, `dp[i+1][j]`, `dp[i][j-1]` 这三个位置：再看看我们确定的 base case，填入 `dp` 数组之后是这样的：
![最长回文子序列dp图解4](./imgs/PalindromeSubseq4.png)
为了保证每次计算 `dp[i][j]`, 左、下、右方向的位置已经被计算出来了，只能斜着遍历(i++,j++)或者反着遍历(i--,j++)。
![最长回文子序列dp图解5](./imgs/PalindromeSubseq5.png)


这里我们选择反着遍历：代码实现请参考 LongestPalindromeSubSeq.java

#### 四、拓展延伸

使然回文相关的问题没有什么特别广泛的使用场景，但是你汇算最长回文子序列以后，一些类似的题目也可以顺手解决掉
比如力扣第 1312 题「计算让字符串成为回文串的最少插入次数」：
输入一个字符串 s，你可以在字符串的任意位置插入任意字符。如果要把 s 变成回文，请你计算最好呀哦今夕多少次插入？
函数签名如下：
```java
int minInsertions(String s);
```

比如说输入 `s="abcea"`，算法返回 2，因为可以给 s 插入 2 个字符变成回文串 "abeceba" 或者 "aebcbea"。如果输入 "aba"，则算法返回0，因为 s 已经是回文串，不用插入任何字符。

这也是一道单字符串的子序列问题，所以我们也可以使用一个二维 dp 数组，其中 dp[i][j] 的定义如下：
**对字符串 s[i..j] ，最少需要进行 dp[i][j] 次插入才能变成回文串**。
根据 `dp` 数组的定义，base case 就是 `dp[i][i] = 0`, 因为单个字符本身就是回文串，不需要插入。然后使用数学归纳法，假设已经计算出了子问题 `dp[i+1][j-1]` 的值了，思考如何推出 `dp[i][j]` 的值：

![最长回文子序列dp图解6](./imgs/PalindromeSubseq6.png)

实际上和最长回文子序列问题的状态转移方程非常类似，这里也分两种情况：
```java
if (s[i] == s[j]) {
    // 根本不需要插入任何字符
    dp[i][j] = dp[i+1][j-1];
} else {
    // 把 s[i+1..j] 和 s[i..j-1] 变成回文串，选择插入次数较少的
    // 然后还要再插入一个 s[i] 或 s[j]，使 s[i..j] 变成回文串
}
```

最后，我们依然采用倒着遍历`dp` 数组的方式，写出代码：
请参考  org.swj.leet_code.algorithm.dynamic_program.subsequence.minInsertion(String s) 方法

至此，这道题也是用了子序列解题模板解决了，整体逻辑和最长回文子序列非常类似，那么这个问题是否可以直接复用回文子序列的解法那？

其实是可以的，我们甚至都不用谢状态转移方程，你仔细想象：

**我先算出字符串 s 的最长回文子序列，哪些不再最长回文中的字符串，不是就要需要插入的字符吗?**

所以这道题可以直接复用之前实现的 `longestPaliddromeSubseq` 函数：
```java
int minInsertion2(String s) {
    return s.length() - longestPalindromeSubeqDpDoubleArray(s);
  }
```
好了，子序列相关的算法就先说到这里。

___ 
### 对动态规划进行降维打击