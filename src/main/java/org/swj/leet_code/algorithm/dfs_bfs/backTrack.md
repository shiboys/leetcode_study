## DFS 

### DFS 算法的使用场景：回溯算法

#### 回溯算法框架：

**抽象地说，解决一个回溯问题，实际上就是遍历一颗决策树的过程，树的每个叶子节点存放着一个合法答案。你把整棵树遍历一遍，把叶子结点上的答案都收集起来，就能得到所有的合法答案**。

站在回溯树的一个节点上，你只需要思考 3 个问题：
1、路径：也就是已经做出的选择。
2、选择列表：也就是你当前可以做的选择
3、结束条件：也就是到达决策树底层，无法再做选择的条件。

如果无法理解三个词语的含义，没关系，我们后面用具体的例子来解释

回溯算法的框架如下：

```py
result=[]
def backtrack(路径,选择列表):
    if 满足结束条件:
        result.add(路径)
        return
    for 选择 in  选择列表:
        做选择
        backtrack(路径，选择列表)
        撤销选择
```

**其核心就是 for 循环里面的递归，在地柜之前「做选择」，在递归调用之后「撤销选择」**，特别简单。

#### 回溯算法之全排列问题

leetcode 第 46 题「全排序列」就是给你输入一个数组 `nums`，让你返回这些数字的全排列


#### N 皇后问题

当 N = 8 时，就是八皇后问题，数学大佬高斯穷尽一生都没数清楚八皇后问题到底有几种可能的放置方法，但是我们的算法只需要一秒就可以算出来所有可能的结果。

不过真不怪高斯，这个问题的复杂度确实非常高，粗略估算一下：

N 行棋盘中，第一行有 N 个位置可能防止皇后，第二行有 N-1 个位置，第三行有 N-2 个位置，以此类推，再叠加每次放皇后之前的 isValid 函数所需的 O(N) 复杂度，所以宗的时间复杂度上界就是 O(N!*N),而且没有什么明显的冗余计算可以优化效率。你可以试试 N=10 的时候，计算就已经很耗时了。

当然，因为有 `isValid` 函数剪枝，并不会真的在每个位置都防止皇后，所以实际的执行效率会高一些。但是总体的这个复杂度作为上界是没问题的。

在简单拓展一下，有可能题目不需要你计算出 N 皇后问题的所有具体结果，而仅仅问你共有几种解法，应该怎么做？

比如 leetcode 第 52 题 「N 皇后 II」

解法就是将 res.add() 改成 queenCount++;

#### 总结

回溯算法就是多叉树的遍历问题，关键就是在前序遍历和后续遍历的位置做一些操作，算法框架如下

```py
def backtrack(...):
    for 选择 in 选择列表:
        做选择
        backtrack(...)
        撤销选择
```

### 回溯算法描述所有的排列-组合-子集问题

无论是排列、组合还是子集问题，简单说无非就是让你从序列 `nums` 中已给定规则获取若干元素，主要有以下几种变体：

**形式一：元素无重复不可复选，即 nums 中的元素都是唯一的，每个元素最多只能被使用一次，这也是最基本的形式，也是最常见的形式(我们本来以为的样子)**。

以组合为例，如果输入 `nums=[2,3,6,7]`, 和为 7 的组合/子集应该只有 `[7]`。

**形式二，可重复但不可复选，即 `nums` 中的元素可以存在重复，每个元素还是最多只能被使用一次**。

以组合为例，如果输入 `nums=[2,5,2,1,2]`, 和为 7 的组合应该有两种 `[2,2,2,1]` 和 `[5,2]` 。

**形式三，元素无重复但可复选，即 `nums` 中的元素是唯一的，但是每个元素可被使用若干次**。

以组合为例，如果输入 `nums=[2,3,6,7]`, 和为 7 的组合应该有两种 `[2,2,3]` 和 `[7]` 。

第四种形式的，元素重复且可复选是没有存在的意义的。

上述用组合问题举例，但排列、组合、子集问题都可以有这三种基本形式，所以共有 9 种变化。

**但无论形式怎么变化，其本质就是穷举所有的解，而这些解呈现树形结构，所以合理使用回溯算法框架，稍微改动代码框架就可以把这些问题一网打尽**。

记住如下的子集问题和排列问题的回溯树，就可以解决所有排列组合子集相关问题：

![排列组合子集问题](../dynamic_programming/imgs/traceback_combination_subset1.png)

![排列组合子集问题](../dynamic_programming/imgs/traceback_combination_subset2.png)

只要能记住这两种树形结构就能解决所有相关问题，这是为什么那？

**首先，组合问题和子集问题是等价的。至于说的前面的三种变化形式，无非就是在这两颗树上减掉或者增加一些树枝罢了**。、

接下来，我们就把排列组合/组合/子集问题的 9 种形式都过一遍，学学如何使用回溯算法把它们一套带走。


#### 子集(元素无重复不可复选)

leetcode 78 题，就是这个问题：

题目给你输入一个无重复元素的数组 nums，其中每个元素最多使用一次，请你返回 nums 的所有子集。

函数签名如下：

```java
List<List<Integer>> subsets(int[] nums)
```
比如输入 `nums=[1,2,3]`, 算法应该返回如下子集：

```java
[ [],[1],[2],[3],[1,2],[1,3],[2,3],[1,2,3] ]
```

请参考 subsets 方法

#### 组合（元素无重复不可复选）

如果你能够成功的生成所有无重子集，那么你稍微改改代码就能生成所有无重组合了。

你比如说，让你在 nums = `[1,2,3]` 中拿 2 个元素形成所有的组合，你怎么做？

稍微想想就会发现，大小为 2 的所有组合，不就是所有大小为 2 的子集嘛。

**所以说组合和子集是一样的：大小为 k 的组合就是大小为 k 的子集**。

比如 leetcode 77 题 「组合」：


给定两个整数 `n` 和 `k`，返回范围 `[1, n]` 中所有可能的 `k` 个数的组合。

函数签名如下：
```java
List<List<Integer>> combine(int n, int k)
```

比如 combine(3, 2) 的返回值应该是：

```text
[ [1,2],[1,3],[2,3] ]
```

这是标准的组合问题，但我给你翻译一下就变成子集问题了：

**给你输入一个数组 `nums=[1,2...n]` 和一个正整数 `k`, 请你生成所有大小为 `k` 的子集**。

还是以 `nums=[1,2,3]` 为例，刚才让我们求所有的子集，就是把所有节点的值都收集起来；**现在你组需要把第 2 层(根节点视为第 0 层)的节点收集起来，就是大小为 2 的所有组合**：

![排列组合子集问题](../dynamic_programming/imgs/traceback_combination_subset6.png)

反映到代码上， 只要稍微改写 base case ，控制算法仅收集第 `K` 层节点的值即可：

```java
void traceBackWithCombineK(int[] nums, int start, int k) {
        if (pathItems.size() == k) {
            res.add(new ArrayList<>(pathItems));
            return;
        }
       // 其他回溯代码....

    }
```

#### 排列(元素无重复不可复选)

全排列 leetcode 46 题已经在 BackTrackFullArrangement 这个类中实现了，这里就略过。示意图如下：

![排列组合子集问题](../dynamic_programming/imgs/traceback_combination_subset7.png)

#### 子集/组合(元素可重复不可复选)

上面讲得标准子集问题 `nums` 是没有重复元素的，但如果存在重复元素，怎么处理？

leetcode 90 题 『子集 II』就是这样一个问题：

给你一个整数数组 `nums`, 其中可能包含重复元素，请你返回钙素组所有可能的子集。

函数签名如下：

```java
List<List<Integer>> subsetsWithDp(int[] nums);
```
比如输入 `nums=[1,2,2]`, 你应该输出：

```java
[ [],[1],[2],[1,2],[2,2],[1,2,2] ]
```

当然， 按道理说集合不应该包含重复元素，但是题目既然这样问了，我们就忽略这个细节吧，仔细思考一下这个题该怎么做才是正事。

就以 `nums=[1,2,2]` 为例，为了区别两个 `2` 是不同的元素，后面我们会写作 `nums=[1,2,2′]`

按照之前的思路画出子集的树形结构，显然，两条值相同的相邻树枝会产生重复：

![排列组合子集问题](../dynamic_programming/imgs/traceback_combination_subset8.png)

```text
[ 
    [],
    [1],[2],[2'],
    [1,2],[1,2'],[2,2'],
    [1,2,2']
]
```
可以看到，`[2]` 和 `[1,2]` 这两个结果出现了重复，所以我么你需要进行剪枝，如果一个节点有多余值相同的树枝相邻，则只遍历第一条边，剩下的都剪掉，不要去遍历：


![排列组合子集问题](../dynamic_programming/imgs/traceback_combination_subset9.png)

**体现在代码上，需要先进行排序，让相同的元素靠在一起，如果发现`nums[i]=nums[i-1]`, 则跳过 `nums[i]`**:

方法 traceBackWithDp 和之前的标准子集问题的代码几乎相同，就是添加了排序和剪枝的逻辑。

至于为什么这样剪枝，结合前面的图应该也很容易理解，这样带重复元素的子集问题也解决了。

我们之前说了**组合问题和子集问题是等价的**，接下来看一道 leetcode 40 题，「组和总和 II」:

给你输入 `candidates` 和一个目标和 `target`，从 `candidates` 中找出所有和为 `target` 组合

`candidates` 可能存在重复元素，且其中的每个数字最多只能使用一次。

说这是一个组合问题，其实换个问题就变成子集问题了：请你计算 `candidates` 中所有和为 `target` 的子集。

所以这题该怎么破？

对比子集问题的解法，只需要额外用一个 `trackSum` 变量记录回溯路径上的元素和，然后将 base case 改一下即可解决这道题

#### 排列（元素可重复不可复选）

排列问题的输入如果存在重复，比子集/组合问题稍微复杂点，比如 leetcode 47 题 「全排列 II」:

给你输入一个可包含重复数字的序列 `nums`, 请你写一个算法，返回所有可能的全排列，函数签名如下：

```java
List<List<Integer>> permuteUnique(int[] nums);
```
比如输入 `nums=[1,2,2]`, 函数返回:

```java
[ [1,2,2],[2,1,2],[2,2,1] ]
```

详细解法请参考 TraceBack 类中的 permuteUnique 方法

对比下之前的 Permutations.java 中的解法，这段代码只有两处不同：

1、对 `nums` 进行了排序
2、添加了一句额外的剪枝逻辑

类比输入包含重复子集/组合的问题，我们能大概了解这么做事为了防止重复结果。

但是注意到排列问题的剪枝逻辑，和子集/组合问题的剪枝逻辑略有不同：**新增了 `!visited[i - 1]` 的逻辑判断。

这个地方理解起来就需要一些技巧，为了方便理解，我们会画图表示，相同的元素会标记 `'` 以示区别。

比如输入为 `nums = [1,2,2]` , 标准的全排列算法会得到如下答案：

```text
[
    [1,2,2'],[1,2',2],
    [2,1,2'],[2,2',1],
    [2',1,2],[2',2,1]
]
```

显然这个结果存在重复，比如 `[1,2,2']` 和 `[1,2',2]` 应该被算作同一个排列，但被算了两个不同的排列。

所以，现在的关键在于，如何设计剪枝逻辑，把这种重复去掉？

**答案是，保证相同的元素在排列中的相对位置保持不变**。

比如说 `nums = [1,2,2']` 这个例子，我们保持排列中 `2` 一直在 `2'` 前面。

这样的话，我们从上面的排列结果中只能挑出 3 个排列符合这个条件：
```text
[ [1,2,2'],[2,1,2'],[2,2',1] ]
```
这也是正确答案。

进一步，如果 `nums=[1,2,2',2'']` , 我们只要保证重复元素 `2` 的相对位置固定，比如说 `2->2'->2''`, 也可以得到无重复的全排列结果。

仔细思考，应该很容易明白其中的原理：

**标准全排列之所以会出现重复，是因为把相同元素想成的排列序列视为不同序列，但实际上他们应该是相同的；而如果固定相同元素形成的序列顺序，当然就避免了重复**。

那么反应到代码上，注意看这个剪枝逻辑：

```java
 if (i > 0 && nums[i] == nums[i - 1] && !visited[i - 1]) {
    // 如果前面的相邻元素没有用过，我也不能用，则跳过。
    continue;
}
// 选择 nums[i]
```

**当出现重复元素时，比如输入 `nums=[1,2,2',2'']` , `2'` 只有在 `2` 已经被使用的情况下才会被选择，同理，`2''` 只有在 `2'` 已经被使用的情况下才会被选择，这样就保证了相同的元素在排列中的相对位置保持固定**。（吐槽下，发现这个特点的人确实对算法然就有一套，我想了半小时左右，愣是没想出来）

这里拓展下，如果把上述的剪枝逻辑中的 `!visited[i-1]` 改为 `visited[i-1]`, 其实也可以通过所有的测试用例，但是效率会有所下降，这是为什么那？

之所以这样修改会产生错误，是因为这种写法相当于维护了 `2''->2'->2` 的相对顺序，最终也可以实现去重的效果。（是的那，如果 2 在 2' 之前被 visit, 那么就会被 continue，最终就是维护了 2''->2'->2 的是相对顺序）。但是为什么这样写效率会下降那？因为这个写法剪掉的树枝不够多，比如输入 `nums=[1,2,2',2'']` ，产生的回溯树如下所示：

![排列组合子集问题](../dynamic_programming/imgs/traceback_combination_subset12.png)

如果用绿色的树枝代表 `backTrack` 函数遍历过的路径，红色树枝代表剪枝逻辑的触发，那么 `!visited[i-1]` 的这种剪枝逻辑得到的回溯树长这样

![排列组合子集问题](../dynamic_programming/imgs/traceback_combination_subset13.png)
(中间的 2' 被剪枝是因为 2 不在 path 上，2'' 被剪枝是因为 2' 不在路径上 )

而 `visited[i-1]` 这种剪枝逻辑得到的回溯树如下：

![排列组合子集问题](../dynamic_programming/imgs/traceback_combination_subset14.png)

(第一个 2' 被剪枝是因为 2 在路径上，第二个 2'' 不被剪枝是因为 2' 不在路径上，但是 2'' 下面的 2' 被剪枝仍然是因为 2 在路径上，这样的结果导致最终的 最右边 2''->2'->2 这个路径没有被任何剪枝，被完全保留了下来，也是符合要求的唯一遍历路径)。

可以看到, `!visited[i-1]` 这种剪枝逻辑减的干净利落，而 `visited[i-1]` 这种剪枝逻辑也能得到无重复结果，但是它剪掉的树枝较少，存在的琑计算较多，所以效率会差些。

当然，关于排列去重，也有其他剪枝思路：

```java
void backTrackPermuteUnique(int[] nums) {
        if (pathItems.size() == nums.length) {
            res.add(new LinkedList<>(pathItems));
        }
        // 题目说 -10 <= nums[i] <= 10
        int prevNum = -888;

        for (int i = 0; i < nums.length; i++) {
            if (visited[i]) {
                continue;
            }

            // 注意这里，虽然说每次递归，prevNum 都会被初始化为 -888, 但是在循环里面也被改了，
            // 如果我们忽略循环中递归函数的调用，就会发现 prevNum 确确实实记录了上一次循环的值，到当前循环中，就是上一次的值
            // 由于数组是排序的，相同的元素排列在一起，所以这个 prevNum 也能起到剪枝的作用
            // 这个剪枝逻辑想明白后，发现也是非常的容易理解，更符合我们平时的习惯和代码的直观思考
            if (nums[i] == prevNum) {
                continue;
            }
            visited[i] = true;
            // 记录这条树枝上的值
            prevNum = nums[i];
            pathItems.add(prevNum);
            backTrackPermuteUnique(nums);
            visited[i] = false;
            pathItems.removeLast();
        }
    }
```

这个思路也是对的，设想一个节点出现了相同的树枝：

![排列组合子集问题](../dynamic_programming/imgs/traceback_combination_subset11.png)

如果不做处理，这些相同的树枝下面的子树也会长得一模一样，所以会出现重复的排列

因为排序之后所有相等的元素紧挨在一起，**所以只要用 `prevNum` 记录前一条树枝的值，就可以避免遍历相同的树枝，从而避免产生相同的子树，从而避免产生相同的子树，最终避免出现重复的排列。**

这样，包含重复输入的排列问题也解决了。

#### 子集/组合(原始无重复可复选)

这个是最后一种类型：输入数组无重复元素，但每个元素可以被无限次使用

leetcode 39 题「组合总和」

给你一个无法重复元素的整数数组 `candidates` 和一个目标和 `target`, 找出 `candidates` 中可以使用数字和为目标数 `target` 的所有组合。`candidates` 中的每个数字可以无限制重复被选取。

函数签名如下：
```java
List<List<Integer>> combinationSum(int[] candidates, int target);
```

比如输入 `candidates=[1,2,3], target=3`, 算法应该返回：

```text
[ [1,1,1],[1,2],[3] ]
```

这道题说是组合问题，实际上也是子集问题，`candidates` 的哪些子集的和为 `target`。

我们想解决这种类型的问题，也得回到回溯树上，**我们不妨先思考思考，标准的子集/组合问题是如何保证不使用重复元素的**?

答案在于 `backtrack` 递归时输入的参数 `start`:

```java
// 无重组合的回溯算法框架
void backtrack(int[] nums, int start) {
    for (int i = start; i < nums.length; i++) {
        // ...
        // 递归遍历下一层回溯树，注意参数
        backtrack(nums, i + 1);
        // ...
    }
}
```

这个 `i` 从 `start` 开始，那么下一层回溯树就是从 `start + 1` 开始，从而保证 `nums[start]` 这个元素不会被重复使用：

![排列组合子集问题](../dynamic_programming/imgs/traceback_combination_subset1.png)

那么反过来，如果我想让每个元素被重复使用， 我只要把 `i+1` 改成 `i` 即可：

```java
// 可重组合的回溯算法框架
void backtrack(int[] nums, int start) {
    for (int i = start; i < nums.length; i++) {
        // ...
        // 递归遍历下一层回溯树，注意参数
        backtrack(nums, i);
        // ...
    }
}
```

这相当于给之前的回溯树添加了一条树枝，在遍历的这棵树的过程中，一个元素可以被无限次使用：

![排列组合子集问题](../dynamic_programming/imgs/traceback_combination_subset10.png)

当然，这样这棵树会永远生长下去，所以我们的递归函数需要设置合适的 base case 以结束算法，即路径和大于 'target' 时就没必要再遍历下去了。

#### 排列(元素无重复可复选)

leetcode 上面没有相似的题目，我们不妨设想一下，`nums` 数组中的元素无重复且可复选的情况下，会有哪些排列

比如输入 `nums=[1,2,3]` ，那么在这种条件下全排列共有 3^3 = 27 中

```java
[
  [1,1,1],[1,1,2],[1,1,3],[1,2,1],[1,2,2],[1,2,3],[1,3,1],[1,3,2],[1,3,3],
  [2,1,1],[2,1,2],[2,1,3],[2,2,1],[2,2,2],[2,2,3],[2,3,1],[2,3,2],[2,3,3],
  [3,1,1],[3,1,2],[3,1,3],[3,2,1],[3,2,2],[3,2,3],[3,3,1],[3,3,2],[3,3,3]
]
```

**标准的全排列算法利用 `used` 数组进行剪枝，避免重复使用同一个元素(避免在同一个遍历路径上再次遍历该元素)。如果允许重复使用元素的话，直接放飞自我，去除所有 `used` 数组的剪枝逻辑就行了**。

那这个问题就简单了，代码如下：

```java
class Solution {

    List<List<Integer>> res = new LinkedList<>();
    LinkedList<Integer> track = new LinkedList<>();

    public List<List<Integer>> permuteRepeat(int[] nums) {
        backtrack(nums);
        return res;
    }

    // 回溯算法核心函数
    void backtrack(int[] nums) {
        // base case，到达叶子节点
        if (track.size() == nums.length) {
            // 收集叶子节点上的值
            res.add(new LinkedList(track));
            return;
        }

        // 回溯算法标准框架
        for (int i = 0; i < nums.length; i++) {
            // 做选择
            track.add(nums[i]);
            // 进入下一层回溯树
            backtrack(nums);
            // 取消选择
            track.removeLast();
        }
    }
}
```

至此，排列/组合/子集问题的九种变化就全部描述完毕。

#### 最后总结

回顾下 排列/组合/子集问题的三种形式在代码上的区别

由于字节问题和组合问题本质上是一样的，无非就是 base case 有一些区别，所以把这两个问题放在一起看。

**形式一，元素无重复不可复选，即 `nums` 中的元素都是唯一的，每个元素最多只能被使用一次**， `backTrack` 的核心代码如下：

```java
// 组合/自己问题的回溯算法框架
void backTrack(int[] nums, int start) {
    //回溯算法标准框架
    for(int i=start; i<nums.length;i++) {
        //做选择
        track.addLast(nums[i]);
        //进行递归，注意参数
        backTrack(nums,i+1);
        //撤销选择
        track.removeLast();
    }
}

// 排列问题回溯算法框架
void backTrack(int[] nums) {
    for(int i=0;i<nums.lenght;i++) {
        if(used[i]) {
            continue;
        }
        //做选择
        used[i]=true;
        track.addLast(nums[i]);
        //进行递归，注意参数
        backTrack(nums);
        //撤销选择
        used[i] = false;
        track.removeLast();
    }
}
```

**形式二、元素可重复不可复选，即 `nums` 中的元素可以存在重复，但是每个元素最多只能被使用一次**，其关键在于排序和剪枝，`backTrack` 的核心代码如下：

```java
Arrays.sort(nums);
// 组合/子集问题回溯框架
void backTrack(int[] nums, int start) {
    // 回溯算法标准框架
    for(int i=start;i<nums.length;i++) {
        if(i>start && nums[i] == nums[i-1]) {
            // 剪枝逻辑，跳过值相同的相邻剪枝
            continue;
        }
        track.addLast(nums[i]);
        // 注意参数
        backTrack(nums, i+1);
        track.removeLast();
    }
}

// 排列问题

Arrays.sort(nums);
void backTrack(int[] nums) {
    for(int i=0;i<nums.length;i++) {
        // 剪枝逻辑
        if(used[i]) {
            continue;
        }
        // 剪枝逻辑，固定 相同的元素在排列中的相对位置。重复元素就像孪生兄弟，老大没有上路，老二老三老n 都不能上路 ，就是都不能被递归到
        if(i>0 && nums[i] == nums[i-1] && !used[i-1]) {
            continue;
        }
        //选择
        used[i]=true;
        track.addLast(nums[i]);
        //递归
        backTrack(nums);
        //撤销选择
        used[i]=false;
        track.removeLast();
    }
}
```

**形式三、元素无重复但可复选，即 `nums`中的元素都是唯一的，每个元素都可以被使用若干次**，只要删掉去重逻辑即可，`backTrack` 核心代码如下：

```java
// 组合子集问题回溯框架
void backTrack(int[] nums, int start) {
    for(int i=start;i<nums.length;i++) {
        // 做选择
        track.addLast(nums[i]);
        //进行队规，注意参数
        backTrack(nums, i);
        // 撤销选择
        track.removeLast();
    }
}

// 排列问题回溯框架
void backTrack(int[] nums) {
    for(int i=start;i<nums.length;i++) {
        // 做选择
        track.addLast(nums[i]);
        //进行队规，注意参数
        backTrack(nums);
        // 撤销选择
        track.removeLast();
    }
}
```

只要从树的角度思考，这些问题看似复杂多变，实则改改 base case 就能解决，这也是为什么我们强调学习二叉树遍历中的树类型题目的重要性。

看到这里，我想大家以后遇到各种乱七八糟的算法题，应该能一眼看穿他们的本质，以不变应万变。


### 回溯法最佳实践——括号生成

leetcode 22 题, 「括号生成」，要求如下：

请你写一个算法，输入时一个正整数 `n`, 输出是`n`对括号的所有合法组合，函数签名如下：
```java
public List<String> generateParenthesis(int n)
```
比如说，输入 `n=3`，输出为如下 5 个字符串：

```java
"((()))",
"(()())",
"(())()",
"()(())",
"()()()"
```

有关括号问题，你只要记住一下性质，思路就很容易想出来：

**1、一个「合法」库昊组合的左括号数量一定等于右括号数量，这个很好理解**
**2、对于一个「合法」的括号字符串组合 `p`, 必然对于任何 `0 <= i <len(p)` 都有：子串`p[0..i]中左括号的数量都大于等于右括号的数量。**

如果不跟你说这个性质，可能不太容易发现，但是稍微想一下，其实很容易理解，因为从左至右算的话，肯定是左括号多嘛，到最后左右括号数量相等，说明这个括号组合是合法的。

反之，比如这个括号组合 `))((`，前几个子串都是右括号数量大于等于左括号，显然不是合法的括号组合。

下面我们就看下 回溯法如何破解这个问题

#### 回溯思路

明白了合法括号的性质括号的性质，如何把这道题和回溯算法扯上关系那？

算法输入一个整数 `n`, 让你计算 **`n` 对括号** 能组成集中合法的括号组合，可以改写成如下问题：

**现有 `2n` 个位置，每个位置可以放置字符 `(`或者 `)`, 组成的所有括号中，有多少个是合法的**？

这个命题和题目的意思完全一样对吧，那么我们先想想如何得到全部 `2^(2n)` 种组合，然后再根据我们刚才总结出的合法括号组合的性质筛选出合法的组合，不就完事了？

如何得到所有组合那？这就是标准的暴力穷举回溯框架呀，之前反复提到的：

```python
def backtrack(路径，选择列表):
    if 满足结束条件:
        result.add(路径)
        return
    for 选择 in 选择列表:
        做选择
        backtrack(路径，选择列表)
        撤销选择
```
那么对于这个需求，我们应该如何打印所有的括号组合那？套一下框架的事，伪代码如下：

```java
void backtrack(int n, int i, StringBuilder track) {
    // 穷举到了最好一个位置
    if(i == 2*n) {
        print(track.toString());
        return;
    }
    
    for choice in ['(',')'] {
        // 做选择
        track.append(choice);
        backtrack(n,i+1,track);
        // 撤销选择
        track.deleteAt(track.length()-1);
    }
}
```

那么，现在就能够打印所有的括号组合了，如何从他们中筛选出来合法的括号组合那？很简单，加几个条件进行「剪枝」就行了。

对于 `2n` 个位置，必然有 `n` 个左括号，`n` 个右括号，所以我们不是简单的记录穷举位置 `i`, 而是**用 `left` 记录还可以使用多少可左括号，用`right` 记录还可以使用多少个右括号**，这样就可以通过刚在总结的合法括号规律进行筛选了：

