### 地下城游戏--魔塔

「魔塔」是一款经典的地牢类游戏，碰到怪物要掉血，吃血瓶能加血，你要收集钥匙，一层一层上楼，最后救出美丽的公主

leetcode 174 题，「地下城游戏」是一道类似的题目，题目的简单描述如下：

输入一个存储着整数的二维数组 `grid`，如果 `grid[i][j] > 0`, 说明这个格子装着血瓶，经过他可以增加对应的生命值；如果 `grdi[i][j] == 0` ，则是一个空格子，经过它不会发生任何事情；如果 `grid[i][j] < 0`, 说明这个格子有怪物，经过他会损失对象的生命值。

现在你是一名骑手，将会出现在最左上角，公主被困于最右下角，你只能向右或者向下移动，请问你初始至少需要多少生命值才能救出公主。

**换句话说，就是问你至少需要多少初始生命值，能够让骑士从最左上角移动到最右下角，且任何时候生命值都大于 0**。

比如如下一个二维数组 grid, 用 K 表示骑士，用 P 表示公主

![地下城游戏例子1](../imgs/game1_1.png)

算法应该返回 7，也就是说骑士的生命初始化至少为 7 才能成功救出公主，行进线路如图中的箭头所示。

这和上篇文章的 《最小路径和》是类似的问题，问你从左上角到右下角的最小路径和是多少。

我们做算法题一定要尝试举一反三，感觉今天这道题和最小路径和有点关系吧？

想要最小化骑士的初始生命值，是不是意味着要最大化骑士行进路线上的血瓶？是不是相当于求「最大路径和」？是不是可以直接套用计算「最小路径和」的思路 ？

但是稍加思考，发现这个推论并不成立，吃到最多的血瓶，并不一定就能获得最小的初始生命值。比如下面这种情况：

![地下城游戏例子1](../imgs/game1_2.png)

但也很容易看到正确答案是下图的箭头所示的路径，初始生命值只需要 1：
![地下城游戏例子1](../imgs/game1_3.png)

**所以，关键不在于吃多少血瓶，而是在于如何损失最少的生命值。**

dp 函数的定义：

**从 `grid[i][j]` 到达终点(右下角)所需的最少生命值是 `dp(grid,i,j)`

根据最新的 dp 函数定义和 base case ，我们想求 `dp(0,0)`，那就应该试图通过 `dp(i+1,j)` 和 `dp(i,j+1)` 推导出 `dp(i,j)` ，这样才能不断逼近 base case ，正确地进行状态转移。

具体来说，「从 A 到右下角的的最少生命值」应该由「从 B 到达右下角的最少生命值」和 「从 C 达到右下角的最少生命值」推导出来：

![地下城游戏例子6](../imgs/game1_6.png)

能不能推导出来那？这是可以的，假设 dp(0,1) = 5, dp(1,0) = 4 ，那么肯定要从 A 走到 C，因为 4 <5 嘛。

那么怎么推导 dp(0,0) 是多少那？
假设 A 的值为 1，既然知道下一步要往 C 走，且 dp(1,0) = 4, 这就意味着走到 grid[1][0] 的时候至少要有 4 点生命值，那么就可以确定骑士出现在 A 点的时候需要 4-1 = 3 的初始生命值。当然如果 A 点的生命值是 10，那么 4-10 =-6 这个也是不符合要求的，如果出现了负数骑士的生命值小于 1 就挂了，所以这种情况下骑士的生命的最小值为 1.

综上：状态转移方程就出来了
```java
int res = min(
    dp(i+1,j),
    dp(i,j+1)
) - grid[i][j]
dp(i,j) = res <= 0 ? 1 : res
```

### 自由之路

leetcode 第 514 题

给你输入一个字符串 ring 代表圆盘上的字符(指针在 12 点钟方向，初始指向 ring[0]) ，再输出一个字符串 key 代表你需要转动圆盘输入的字符串，你的算法需要返回输入这个 key 至少要进行多少次操作(拨动一个圆盘和按下中间的按钮都是一次操作)
举例如下：输入 `ring="godding"，key= "gd"`，对应的圆盘如下:

![地下城游戏例子1](../imgs/game2_3.jpg)

如果我们输入的 `key = "gd" `，算法返回 4。
因为指针现在的字母是 g，可以直接按下中间按钮，然后再将圆盘逆时针波动两格，让指针指向字母 "d"，然后再按下中间按钮一次。

上述过程，按了两次按钮，拨了两格转盘，共操作 4 次，是最少的操作次数，所以算法返回 4.

这里我们首先给题目做一个等价转换，转动圆盘是不就就等于波动指针？

**原题可以转化为：圆盘固定，我们可以波动指针；现在需要我们波动指针并按下按钮，以最少的操作次数输入 `key` 对应的字符串**。

「状态」和「选择」是什么？
**「状态」就是「当前需要如输入的字符」和「圆盘当前的指针位置也就是当前要输入的字符」**

dp 函数可以定义为 :
```java
int dp(String ring,int i, String key, int j);
```
定义文字解释如下：
当圆盘指针指向 `ring[i]` 时，输入字符串 `key[j..]` 至少需要 `dp(ring,i,key ,j)` 次操作。

### 用动态规划解决 加权最短路径

力扣 787 题 「K站内最便宜的航班」，题目描述如下：

现在有 n 个城市，分别用 0,1...n-1 这些序号表示，城市之间的航线用三元组 `[from,to,price]` 来表示，比如说三元组 `[0,1,100]` 就表示，从城市 0 到 城市 1 之间的机票价格是 100 元。

题目会给你输入若干参数：正整数 n 代表了城市个数，数组 `flights` 装着若干三元组嗲表城市之间的航线以及价格，城市编号 src 代表了你所在的城市，城市标号 dst 代表了你要去的目标城市，整数 K 代表了你最多经过的中转站个数。
函数签名如下：
```java
int findCheapestPrice(int n, int[][] flights, int src, int dst,int K);
```
请你的算法计算，在 `K` 次中转之内，从 src 到 dst 所需的最小花费是多少钱，如果无法到达，则返回 -1。比如说，题目给的例子
`n=3, flights=[[0,1,100],[1,2,100],[0,2,500]], src=0, dst=2, k=1`

航线就是下面这张图，所有有向边代表了航向的方向，边上的数字代表了航线的机票价格
![加权最短路径图1](../imgs/game3_1.png)
出发点是 0，到达点是 2，允许的最大中转次数 K 为 1，所以最小的开销就是图中红色的两条边，从0 出发，经过中转城市，经过中转城市 1 到达目标城市 2，所以算法的返回值应该是 200。

注意这个中转次数的上限 K 是比较棘手的，如果上述题目将 K 改成 0，那也就是不允许中转，那么我们的算法只能返回 500 了，也就是从 0 飞到 2。

**很明显，这题就是个加权有向图中求最短路径的问题**。 说白了，就是给你一副加权有向图，让你求 src 到 dst 权重最小的一条路径，同时要满足，这条路径最多不能超过 `K+1` 条边（经过 K 个节点相当于经过 `K+1` 条边）。

#### 算法思路：

下面分析相关算法：

BFS 算法思路：

对于加权图的场景，我们需要优先级队列「自动排序」的特性，将路径权重较小的节点排在队列前面，以此基础施展 BFS 算法，也就变成了 Dijstra 算法。
Dijstra 算法本篇章暂不涉及，后面的图论相关的算法会重写该方法

##### 动态规划思路：

求最值的问题，很多都可能使用动态规划来求解。
加权最短路径问题，再加个 `K` 的限制也无妨，不就是求最值的问题嘛，动态规划统统拿下。
我们先不管 K 的限制，单就「加权最短路径」这个问题来看，他怎么就是个动态规划问题了那？比方说，我们想计算 src 到 dst 的最短路径：
怎么从 src 到 dst 我不知道，但我可以把问题分解：

![加权最短路径动态规划分解1](../imgs/game3_2.png)

`s1, s2` 是指向 dst 的相邻节点，他们之间的权重我是知道的，分别是 `w1, w2`。
只要我知道了从 `src` 到 `s1,s2` 的最短路径，我不就知道了从 `src` 到 `dst` 的最短路径了吗？

```java
minPath(src,dst) = min(
    minPath(src,s1) + w1,
    minPath(src,s2) + w2
)
```

这其实就是递归关系了，就是这么简单。

**不过别忘了，题目对我们的最短路径还有个「路径上不能超过 `K+1` 条边」的限制**。

___
### 经典动态规划，正则表达式

leetcode 第 10 题，正则表达式匹配。题目要求如下：
实现一个简单的正则匹配算法，包括「.」通配符和「*」通配符。

这两个通配符是最常用的，其中点号「.」 可以匹配任意一个字符，星号「*」可以让之前的那个字符重复任意次数(包括 0 次)。

比如说模式串 `".a*b"` 就可以匹配文本 `"zaaab"` ，也可以匹配 `"cb"`；模式串 "a..b" 可以匹配文本 `"amnb"`; 而模式串 `".*"` 就比较牛逼了，它可以匹配任何文本。

题目会给我们输入了字符串 `s` 和 `p`，s 代表文本，p 代表模式串，请你判断模式串 p 是否可以匹配文本 s。我们可以假设模式串只包含小写字母和上述两种通配符且一定合法，不会出现 `*a` 或者 `b**` 这种不合法的模式串：

```java
boolean isMatch(String s, String p);
```

对于我们将要实现的这个正则表达式，难点在哪里那？

点号通配符其实很好实现，`s` 中的任何字符，只要遇到 `.` 通配符，就可以无脑匹配就完事了。主要是这个星号通配符不好实现，一旦遇到 `*` 通配符，前面的那个字符可以选择重复一次，可以重复多次，也可以一次都不出现，这该怎么办？

对于这个问题，答案很简单，对于所有可能出现的情况，全部穷举一遍，只要有一种情况可以完成匹配，就认为 `p` 可以匹配了 `s`。那么一旦涉及两个字符串的穷举，我们就应该条件反射第想到动态规划技巧了。

#### 一、思路分析
我们先脑补一下，s 和 p 相互匹配的过程大致是，两个指针 i 和 j 分别在 s 和 p 上移动，如果最后两个指针都能移动到字符串的末尾，那么就匹配成功，反之匹配失败。

**如果不考虑 `*` 通配符，面对两个待匹配的字符串 `s[i]` 和 `s[j]` ，我们唯一能做的就是看他俩是否匹配：**

```java
boolean isMatch(String s, String p) {
    int i=0,j=0;
    while(i<s.length() && j<p.length()) {
        // . 号通配符就是万金油
        if(s.charAt(i) == p.charAt(j) || p.charAt(j) == '.') {
            // 匹配，接着匹配 s[i+1..]和p[j+1..]
            i++;j++;
        } else {
            //不匹配
            return false;
        }
    }
    return  i==j;
}
```
那么考虑一下，如果加入 `*` 通配符，局面就会稍微复杂一些，不过要分情况请来分析，也不难理解。
**当 `p[j+1]` 为 `*` 通配符时，我们分情况讨论下：**

1、如果 `s[i] == p[j]`，那么会有两种情况：
    1.1 `p[j]` 有可能会匹配多个字符，比如 `s[i] == "aaa", p="a*"`, 那么 `p[0]` 会通过 `*` 匹配 3 个字符 `"a"`。
    1.2 `p[j]` 有可能会匹配0个字符，比如 `s[i] == "aa", p="a*aa"`，由于后面的字符可以匹配 `s`, 所以 p[0] 只能匹配 0 次。

2、如果 `s[i] != p[j]`, 只有一种情况：

`p[j]` 只能匹配 0 次，然后看看下一个字符能否和 `s[j]` 匹配。比如说 `s[i] == "aa", p="b*aa"`, 此时 `p[0]` 只能匹配 0 次。

综上，可以把之前的代码块针对 `*` 通配符进行一下改造：
```java
if (s[i] == p[j] || p[j] == '.') {
    // 匹配
    if(j < p.length() - 1 && p.charAt(j+1) == "*") {
        // 有 * 通配符，可以匹配 0 次或者多次
    } else {
        // 无 *  通配符，老老实实的匹配 1 次
        i++;j++;
    }
} else {
    if(j < p.length() -1 && p.charAt(j+1) = '*') {
        // 有 * 通配符，可以匹配 0 次

    } else {
        // 无 * 通配符
        return false;
    }
}
```

整体思路已经很清晰了，但是现在的问题是，遇到`*` 通配符时，到底应该是匹配 0 次还是匹配多次？多次是几次？

你看，这就是一个做「选择」的问题，要把所有可能的选择都穷举一遍才能得出结果。动态规划算法的核心就是「状态」和「选择」。**「状态」无非就是 `i` 和 `j` 两个指针的位置，「选择」就是 `p[j]` 选择匹配几个字符**。

#### 二、动态规划解法

根据状态，我们可以定一个 `dp` 函数：
```java
boolean dp(String s,int i,String p ,int j);
```
dp 函数的定义如下：

**若 `dp(s, i, p, j) = true`，则表示 `s[i..]` 可以匹配 `p[j..]`; 若 `dp(s, i, p, j) = false`, 则表示  `s[i..]` 无法匹配 `p[j..]`**。

#### 备忘录的使用推导

代码中使用了一个 `memo` 备忘录消除重叠子问题。如何一眼看出重叠子问题？根据之前的动态规划经验中所讲的技巧，抽出正则表达式的递归框架

```java
boolean dp(String s,int i,String p,int j) {
    ds(s,i,p,j); // 1
    dp(s,i+1,p, j); // 2
    dp(s,i+1,p, j+1); // 3
    dp(s,i, p, j+2); //4
}
```
如果让你从 `dp(s,i,p,j)` 得到 `dp(s,i+2,p,j+2)` , 至少有两条路径`1->2->2` 或者 `3->3`。这就说明 `(i+2,j+2)` 这个状态的计算必然存在重复，也就是说明存在重叠子问题，我们需要使用备忘录消除重叠子问题，提高效率

___
### 动态规划经典：高楼扔鸡蛋

#### 问题描述
本章节聊一个很精单的算法问题，若干楼层，若干鸡蛋，让你算出最少的尝试次数，找到鸡蛋恰好摔不碎的那层楼。国内大厂以及谷歌脸书面试经常考察这道题，只不过他们觉得扔鸡蛋太浪费，改成扔盘子，扔破碗什么的。

这道题的解法很巧，光动态规划就好几种效率不同的思路。接下来我们就来通过动态规划来研究下这道题

leetcode 第 887 题，鸡蛋掉落，题目描述如下：

你面前有一栋从 1 到 N 共 N 层的楼，然后给你 K 个鸡蛋（K 至少为 1）。现在确定这栋楼存在楼层 `0=<F <=N`, 在这层将鸡蛋扔下去，鸡蛋**恰好没有摔碎**(高于 F 的楼层都会碎，低于 F 的楼层都不会碎，如果鸡蛋没有碎，可以捡回来继续扔)。现在问你，**最坏**情况下，你至少要仍几次鸡蛋，才能确定这个楼层 F 那？

什么叫「最坏情况」下「至少」要扔几次那？我们分别举个栗子就明白了。

比方说**现在先不管鸡蛋个数的限制**，有 7 层楼，你怎么去找鸡蛋恰好摔碎的那层楼？
最原始的方式就是线性扫描，每层都扔一下试试
以这种策略，**最坏**情况下应该就是我试到了第 7 层鸡蛋也没有碎(F==7), 也就是我扔了 7 次。
现在理解了最坏情况了吧？ **鸡蛋破碎一定发生在搜索区间穷尽时**，不会说你在第 1 层摔一下鸡蛋就碎了，这是你运气好，不是最坏情况。

再来理解设密码叫「至少」要仍几次。依然是不考虑鸡蛋个数限制，同样是 7 层楼，我们可以优化策略。
最好的策略是使用二分法查找思路，我先去第 (1 + 7) / 2 = 4 层扔一下：

如果碎了说明 F 小于 4，我就去第 (1 + 3) / 2 = 2 层试……

如果没碎说明 F 大于等于 4，我就去第 (5 + 7) / 2 = 6 层试……

以这种策略，最坏情况应该是试到第 7 层鸡蛋还没碎（F = 7），或者鸡蛋一直没碎到第 1 层（F = 0）。然而无论那种最坏情况，只需要试 log7 向上取整等于 3 次，比刚才尝试 7 次要少，这就是所谓的**至少**要扔几次。

实际上，如果不限制鸡蛋个数的话，二分思路显然可以得到最少尝试的次数，但问题是，**现在给你的鸡蛋个数限制 K，直接使用二分思路就不行了**。

比如说给你 1 个鸡蛋，7 层楼高，你敢二分吗？你直接去第 4 层扔一下，如果鸡蛋没碎还好，，你可以把鸡蛋捡起来继续去更高的楼层尝试；但是如果碎了，你就没有鸡蛋继续测试了，无法确定鸡蛋恰好摔不碎的楼层 F 了。

其实只有 1 个鸡蛋的时候，只能从下往上一层层尝试扔鸡蛋，最坏情况下需要扔 7 次。

#### 思路分析：

动态规划问题，有什么「状态」，有什么「选择」，然后穷举。
**「状态」很明显：就是当前拥有的鸡蛋个数 k 和需要测试的楼层数 N**。随着测试的进行，鸡蛋个数可能减少，楼层的搜索范围也会减小，这就是状态的变化。

**「选择」其实就是去选择那层楼扔鸡蛋**。不同的选择会造成状态的转移。

现在明确了「状态」和「选择」，**动态规划的思路就形成了**，肯定是个二维的 `dp` 数组或者带两个参数的 dp  函数来表示状态转移，外加一个 for 循环来遍历所有选择，选择最优的状态：

状态转移部分：

我们选择第 i 层扔鸡蛋之后，可能出现两种请，鸡蛋碎了，鸡蛋没碎。**注意：这个时候状态转移来了**：

**如果鸡蛋碎了**，那么鸡蛋的个数 K 应该减一，搜索的楼层应该从 `[1..N]` 变为 `[1..i-1]` 共 `i-1` 层楼；
**如果鸡蛋没碎**，那么鸡蛋的个数 K 不变，搜索的楼层区间应该从  `[1..N]` 变为 `[i+1..N]` 共 `N-i` 层楼；

![扔鸡蛋1](../imgs/drop_egg1.png)

因为我们要求的是 **最坏情况**下扔鸡蛋的次数，所以鸡蛋在第 `i` 层楼没有碎，取决于那种情况的结果**更大**:
```python
int dp(int k, int N):
    for 1 <= i <= N:
        res = min(res,
                    max(
                        dp(k-1, i -1) , # 碎了的函数
                        dp(k, N -i) # 没碎函数
                    ) + 1 # 在第 i 楼扔了 1 次。
        )
return res;
```
递归的 base case 也很好理解，N=0 的时候，显然不需要扔鸡蛋；当鸡蛋数 K 为 1 的时候，显然只能线性扫描所有楼层

```java
int dp(int K, int N) {
    if(N==0)  return 0;
    if(K==1) return N;
    //...
}
```
具体解法参见代码

这个 for 循环就是下面这个状态转移方程的具体代码实现

![楼下扔鸡蛋](../imgs/drop_egg_formula1.png)

首先我们根据 dp(K, N) 数组的定义（有 K 个鸡蛋面对 N 层楼，最少需要扔几次），**很容易知道 K 固定时，这个函数随着 N 的增加一定是单调递增的**，无论你策略多聪明，楼层增加测试次数一定要增加。

那么注意 dp(K - 1, i - 1) 和 dp(K, N - i) 这两个函数，其中 i 是从 1 到 N 单增的，如果我们固定 K 和 N，把这两个函数看做关于 i 的函数，**前者随着 i 的增加应该也是单调递增的，而后者随着 i 的增加应该是单调递减的**

![楼下扔鸡蛋](../imgs/drop_egg2.png)

这时候求二者的较大值，再求这些最大值之中的最小值，其实就是求这两条直线交点，也就是红色折线的最低点嘛。

这样就能用二分法了，二分查找的运用很广泛，只要能够找到具有单调性的函数关系，都很有可能运用二分法来优化线性搜索的复杂度。回顾这个 dp 函数的曲线，我们要找的最低点其实就是这种情况：
```java
for (int i = 1; i <= N; i++) {
    if (dp(K - 1, i - 1) == dp(K, N - i))
        return dp(K, N - i);
}
```

熟悉二分搜索的同学肯定敏感地想到了，这不就是相当于求 Valley（山谷）值嘛，可以用二分查找来快速寻找这个点的，参考相关代码吧！

下面是 在油管上看到的油管 这道题的解法和相关画图

base case 有增加：
1、N==1 时，K >0 ,则 dp(K,N) = 1 因为只有1层楼时，只需要扔 1 次

K=2,N=6 时的递归树如下：
![扔鸡蛋油管解法](../imgs/dropegg_yt1.png)
从这张递归树中能更清楚的看到，我们要求的是从第 3 层楼进行扔的时候，能得出最小的扔鸡蛋次数 3。

![扔鸡蛋油管解法](../imgs/dropegg_yt2.png)
从这张图中，我们更能看出 dp(k-1,i-1) 的单调递增性 和 dp(k,n-i) 的单调递减性

___
### 股票交易

#### 一、穷举框架
如何穷举：
动态规划的本质是穷举「状态」，然后在「选择」中选择最优解。
这道题，选择有三种：「买入」「卖出」「无操作」, 即 buy,sell, rest
状态有 3 个，第一个是价格天数，第二个是允许交易的最大次数，当前的持有状态(即 rest 的状态，1 为持有，0 为不持有)，然后我们用一个三维数组就可以装下这几个状态的全部组合：
```py
dp[i][k][0 or 1]
0=<i<=n-1, 1 =< k <= K。
n 为天数，大 K 为交易次数的上限，0 和 1 代表是否持有股票
此问题共有 n * K * 2 种状态，全部穷举能搞定

for 0 <= i < n:
    for 1 <= k <= K:
        for s in {0, 1}:
            dp[i][k][s] = max(buy, sell, rest)
```
而且我们可以用自然语言描述出每一个状态的含义，比如说 dp[3][2][1] 的含义就是：今天是第三天，我现在手上持有着股票，至今最多进行 2 次交易。再比如 dp[2][3][0] 的含义：今天是第二天，我现在手上没有持有股票，至今最多进行 3 次交易。很容易理解，对吧？

我们想求的最终答案是 dp[n - 1][K][0]，即最后一天，最多允许 K 次交易，最多获得多少利润。

记住如何解释「状态」，一旦你觉得哪里不好理解，把它翻译成自然语言就容易理解了。



#### 二、状态转移框架
首先请看状态转移图

![状态转移图](../imgs/stock_exchange_dp1.png)

根据上图，我们来写出状态转移方程：

```python
dp[i][k][0] = max(dp[i-1][k][0], dp[i-1][k][1] + prices[i])
              max( 今天选择 rest,        今天选择 sell       )
```
解释：今天我**没有**持有股票，有两种可能，我从这两种可能中求最大利润：

1、我昨天就没有持有，且截至昨天最大交易次数限制为 k；然后我今天选择 rest，所以我今天还是没有持有，最大交易次数限制依然为 k。

2、我昨天持有股票，且截至昨天最大交易次数限制为 k；但是今天我 sell 了，所以我今天没有持有股票了，最大交易次数限制依然为 k。

```python
dp[i][k][1] = max(dp[i-1][k][1], dp[i-1][k-1][0] - prices[i])
              max( 今天选择 rest,         今天选择 buy         )

```

解释：今天我**持有**着股票，最大交易次数限制为 k，那么对于昨天来说，有两种可能，我从这两种可能中求最大利润：

1、我昨天就持有着股票，且截至昨天最大交易次数限制为 k；然后今天选择 rest，所以我今天还持有着股票，最大交易次数限制依然为 k。

2、我昨天本没有持有，且截至昨天最大交易次数限制为 k - 1；但今天我选择 buy，所以今天我就持有股票了，最大交易次数限制为 k(每次 buy，交易次数 +1)。


**注意 `k` 的限制，在选择 buy 的时候相当于开启了一次交易，那么对于昨天来说，交易次数的上限 k 应该减小 1**


```javascript
dp[-1][...][0] = 0
解释：因为 i 是从 0 开始的，所以 i = -1 意味着还没有开始，这时候的利润当然是 0。

dp[-1][...][1] = -infinity
解释：还没开始的时候，是不可能持有股票的。
因为我们的算法要求一个最大值，所以初始值设为一个最小值，方便取最大值。

dp[...][0][0] = 0
解释：因为 k 是从 1 开始的，所以 k = 0 意味着根本不允许交易，这时候利润当然是 0。

dp[...][0][1] = -infinity
解释：不允许交易的情况下，是不可能持有股票的。
因为我们的算法要求一个最大值，所以初始值设为一个最小值，方便取最大值。
```

把上面的状态转移方程总结一下：

```py
base case：
dp[-1][...][0] = dp[...][0][0] = 0
dp[-1][...][1] = dp[...][0][1] = -infinity

状态转移方程：
dp[i][k][0] = max(dp[i-1][k][0], dp[i-1][k][1] + prices[i])
dp[i][k][1] = max(dp[i-1][k][1], dp[i-1][k-1][0] - prices[i])
```

#### 股票相关题目解决
##### 股票买卖第一题
**第一题，先说力扣 121 题「买卖股票的最佳时机」，相当于 `k = 1` 的情况：
![股票买卖第一题](../imgs/stock_title1.png)

直接套状态转移方程，根据 base case ，可以做一些简化：
```python
dp[i][1][0]=max(dp[i-1][1][0], dp[i-1][1][1] + price[i])
dp[i][1][1]=max(dp[i-1][1][1], dp[i-1][0][0] - price[i])
            =max(dp[i-1][1][1], - price[i])
解释 k=0 的 base case ，所以 dp[i-1][0][1] = 0。
现在发现 k 都是 1，不会改变了，即 k 对应的专题转移已经没有了影响了。
可以进行进一步的简化去掉所有的 k:
dp[i][0] = max(dp[i-1][0], dp[i-1][1] + price[i])
dp[i][1] = max(dp[i-1][1], - price[i])
```
因此可以直接写出代码

##### 股票交易第二题

![股票交易第二题](../imgs/stock_title2.png)

题目还专门强调可以在同一天出售，但是我觉得这个条件纯属多余，如果当天买卖，那利润当然就是 0， 这不是和没有进行交易一样的吗？这道题的特点在于没有给出交易总数 `k` 的限制，也就是相当于 `k` 为正无穷。

如果 `k` 为正无穷，那么可以认为 `k` 和 `k-1` 是一样的。可以这样改写框架：

```python
dp[i][k][0] = max(dp[i-1][k][0], dp[i-1][k][1] + prices[i])
dp[i][k][1] = max(dp[i-1][k][1], dp[i-1][k-1][0] - prices[i])
            = max(dp[i-1][k][1], dp[i-1][k][0] - prices[i])

我们发现数组中的 k 已经不会改变了，也就是说不需要记录 k 这个状态了：
dp[i][0] = max(dp[i-1][0], dp[i-1][1] + prices[i])
dp[i][1] = max(dp[i-1][1], dp[i-1][0] - prices[i])
```

##### 第三题，力扣 309 「最佳买卖股票时期含冷冻期」

**这道题也就是 `k` 为正无穷，但含有交易冷冻期的情况**

![股票交易第三题](../imgs/stock_title3.png)

在满足约束条件下，你可以尽可能地完成更多的交易，但卖出股票后，你无法在第二天买入股票(及冷冻期为 1 天)。

和上一题一样，只不过每次 `sell` 之后要等一天才能继续交易，只要把这个忒单容易上一题的状态转移方程就行
```py
dp[i][0] = max(dp[i-1][0],dp[i-1][1] + prices[i]);
dp[i][1] = max(dp[i-1][1], dp[i-2][0] - prices[i]);
解释：先卖出，再买入 。中间有 1 天的冷冻期，所以 i-2 表示上一次的卖出。
```

##### 第 4 题，买卖股票的最佳时机含手续费。

**也就是说 `k` 为正确穷且考虑手续费的情况** ：

![股票交易第四题](../imgs/stocktitle4.png)

每次交易都需要支付手续费，只要把手续费从利润中减去即可，改写方程
```py
dp[i][0]=max(dp[i-1][0],dp[i-1][1] + prices[i])
dp[i][1]=max(dp[i-1][1],dp[i-1][0] - prices[i] - fee)
解释：相当于买入股票的价格升高了
在第一个式子里减也是一样的，相当于卖出股票的价格减小了。不过算法上为了阅读着更舒服，选择买入了股票买入价格增加。
```

##### 第五题，leetcode 123 题，「买卖股票的最佳时机 III」,也就是 `k==2` 的时候

![股票交易第四题](../imgs/stocktitle5.png)

`k=2` 和前面的题目稍微不同，因为上面的情况和 `k` 的关系不太大，要嘛 `k` 是正无穷，状态转移和 `k` 没关系了; 要嘛 `k=1` 跟 `k=0` 这个 base case 挨得很近，最后也没有存在感。

这道题的 `k=2` 和后面要说的 k 是任意正整数的情况中，对 `k` 的处理就凸显出来了，我们直接写代码，低吗中编写分析原因

```py
原始的状态转移方程，没有可用简化的地方
dp[i][k][0]= max(dp[i-1][k][0],dp[i-1][k][1] + price[i])
dp[i][k][1]= max(dp[i-1][k][1],dp[i-1][k-1][0] - price[i])
```
>**这里有个疑问，`k` 的 base case 是 0，按理说应该从 k =1，k++ 这样穷举状态 `k` 才对？而且如果你真的这样从小到大遍历 k，提交发现也是可以的。**

这个疑问很正确，但为什么我们从大到小遍历 k 也是可以正确提交那？因为你注意看，`dp[i][k][..]` 不会依赖 `dp[i][k-1][..]` 而是依赖 `dp[i-1][k-1][..]` ,而 `dp[i-1][..][..]` 都是已经计算出来的，所以不关你是 `k=max_k,k--` 还是 `k=1, k++`,都可以的得出正确答案，

那为什么我们这里使用 `k=max_k,k--` 的方式那？因为这样符合语义：

你买股票，初始「状态」是什么？应该是从第 0 天开始，而且是没有进行过买卖，所以最大交易次数限制 `k` 应该是 max_k; 而随着状态的转移，你会进行交易，那么交易次数上线 `k` 应该不断减少，这样一想， `k=max_k,k--` 的方式是比较合乎实际场景的。

当然，这里 `k` 取值范围比较小，所以也可以不用 for 循环，直接把 k=1 和 2 的情况全部列举出来也可以
```java
int maxProfit_k_2_2(int[] prices) {
        
        /**
         * 状态转移方程：
         * dp[i][2][0]=max(dp[i-1][2][0], dp[i-1][2][1] + price[i]);
         * dp[i][2][1]=max(dp[i-1][2][1], dp[i][1][0] - price[i])
         * dp[i][1][0]=max(dp[i-1][1][0], dp[i-1][1][1] + price[i]);
         * dp[i][1][1]=max(dp[i-1][1][1], -price[i])
         */
        int dp_i20 = 0,dp_i21 = Integer.MIN_VALUE;
        int dp_i10 = 0,dp_i11 = Integer.MIN_VALUE;
        for(int price : prices) {
            // 这里为何先算 dp_i20 和 dp_i21 那？这是因为上面的代码中 10 和 11 算完之后 continue了，就是为了给下一轮的 20 和 21 使用
            // 所以这里尽管先初始化 20 和 21 ，但是首次的 max 求值因为存在极值，是没问题的
            dp_i20 = Math.max(dp_i20, dp_i21 + price);
            dp_i21= Math.max(dp_i21, dp_i10 - price);
            dp_i10 = Math.max(dp_i10, dp_i11 + price);
            dp_i11 = Math.max(dp_i11, -price);
        }
        return dp_i20;
    }
```
状态转移方程和含义明确的变量名称知道，相信大家很容易看懂。其实如果我们故弄玄虚，把上述 4 个变量编程 `a、b、c、d`。这样当兵别人看到你的代码的时候，就会觉得你很牛逼~ ~

##### 第 6 题，买卖股票的最佳时机 leetcode 188 题
即 `k` 是题目给定的任何数的情况：

![股票交易6](../imgs/stock_title.png)

有了上一题 `k=2` 的铺垫，这题应该和上一题的第一个解法没啥区别，我们把上一题的 `K=2` 换成提提输入 `k` 就行了。

但试一下会发现会出现一个内存超限的错误，原来是传入的 k 值会非常大，dp 数组太大了。那么现在详细，交易次数 k 最大是多大那？

一次交易由买入和卖出构成，至少需要两天。所以说，有效的限制 k 应该不超过 n/2 ,如果超过，就没有约束作用了，相当于 k 没有限制的情况。

所有我们可以直接使用之前的函数。请参考实现方法maxProfit_k_any()

