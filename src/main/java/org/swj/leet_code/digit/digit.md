## 数字问题

### 阶乘问题

#### 阶乘后的零

leetcode 172

给定一个整数 n ，返回 n! 结果中尾随零的数量。

提示 `n! = n * (n - 1) * (n - 2) * ... * 3 * 2 * 1`

示例 1：

> 输入：n = 3
>输出：0
>解释：3! = 6 ，不含尾随 0

示例 2：

>输入：n = 5
>输出：1
>解释：5! = 120 ，有一个尾随 0

肯定不可能真去把 `n!` 的结果算出来，阶乘增长可是比指数增长都恐怖，趁早死了这条心吧！

那么，结果的末尾的0从哪里来的？我们有没有投机取巧的方法计算出来？

首先，两个数相乘结果末尾有0，一定能柜式两个数中有因子 2 和 5，因为 10=2x5。

**也就是说，问题转化为：`n!` 最多可以分解除多少个因子 2 和 5**？

比如说 `n=25`, 那么 `25!` 最多可以分解除几个 2 和 5 想成？这个主要取决于能分解除几个因子 5 ，因为每个偶数都能分解出因子 2，因此因子 2 肯定比因子 5 多得多。

`25!` 中 5 可以提供一个，10 可以提供一个，15 可以提供一个，20 可以提供一个，25 可以提供两个，总共有 6 个因子5，所以 `25!` 的结果末尾就有 6 个 0。

**现在，问题转化为 `n!` 最多可以分解出多少个因子 5**?

这样，我们假设 `n=125`, 来算一算 `125!` 的结果末尾有几个 0：

首先 ，125/5=25，这一步就是计算出有多少个像，5,10,15,20,25 这些 5 的倍数，他们一定可以提供一个因子 5。

但是这些足够吗？刚才说了，像 25,50，75 这些 25 的倍数，可以提供两个因子 5，那么我们在计算出 `125!` 中有 125/25=5 个 25 的倍数，它们每个人都可以额外在再供一个因子 5。

够了吗？我们发现 125 = 5x5x5 ，向 125,250 这些 125 的倍数，可以提供 3 个因子 5，那么我们还得在计算出 `125!` 中有 125/125=1 个 125 的倍数，它还可以额外再提供一个因子 5。

这些应该够了，`125!` 最多可以分解除 25+5+1=31 个因子 5，也就是阶乘的结果有 31 个 0.

理解了这个思路，我么就可以理解解法代码了：

```java
public int trailingZeroes(int n) {
        long dividor = 5;
        int res = 0;
        while (dividor <= n) {
            res += n / dividor;
            dividor *= 5;
        }
        return res;
    }
```

这里 `dividor` 变量使用 long 型，因为加入 `n` 比较大，考虑到 while 循环结束的条件， `dividor` 可能出现整型溢出。

上述代码可以更加简洁：

```java
public int trailingZeros2(int n) {
        int res = 0;
        for (long dividor = 5; dividor <= n; dividor *= 5) {
            res += n / dividor;
        }
        return res;
    }
```

这样，这道题就解决了，时间复杂度是底数为 5 的堆数，也就是 `O(logN)`, 我们看看如何基于这道题的解法来解决一道更深层次的问题。

### 793. 阶乘函数后 K 个零

`f(x)` 是 `x!` 末尾是 0 的数量。回想一下 `x! = 1 * 2 * 3 * ... * x`，且 0! = 1 。
 * 例如， `f(3) = 0` ，因为 `3! = 6` 的末尾没有 0 ；而 `f(11) = 2` ，因为 `11!= 39916800` 末端有 2 个 0 。

给定 `k`, 找出返回能满足 `f(x) = k` 的非负整数 `x` 的数量

函数签名如下：
```java
public int preimageSizeFZF(int k) {

    }
```

示例1：
>输入：k = 0
>输出：5
>解释：0!, 1!, 2!, 3!, 和 4! 均符合 k = 0 的条件。

一个直观暴力方法就是穷举，因为随着 `n` 的增加， `n!` 肯定是递增的，`trailingZeroes(n!)` 肯定也是递增的，伪代码如下

```java
int res=0;
for(int n=0;n<+inf;n++) {
    if(trailingZeroes(n) < k) {
        continue;
    }
    if(trailingZeroes(n) > k) {
        break;
    }
    if(trailingZeroes(n) == k) {
        res++;
    }
}
return res;
```
之前做二分查找的时候说过，**对于这种具有单调性的函数，用 for 循环遍历，可以用耳返查找进行降维打击**, 对吧。

搜索多少个 `n` 满足 `trailingZeroes(n) == k`, 其实就是在问，**满足条件的 `n` 最小是多少，最大是度多少，最大值和最小值一减，就可以算出多少个 `n` 满足条件了**，对吧？这不就是二分查找中「搜索最左侧边界」和「搜索最右侧边界」这两个事吗？

先不着急写代码，因为二分查找需要一个搜索区间，也就是上界和下界，上述伪代码中 n 的下界自然是0，但是上界是 `+inf`, 这个正无穷如何表示出来那？

首先，数学上的争取穷是无法用编程表示出来的，我们一般的方法是用一个非常大的值，达到这个值一定不会被取到。比如说 int 类型的最大值 `INT_MAX`(2^31-1,大约 31 亿)，这还不够的话 long 类型的最大值 `LONG_MAX`（2^63-1，这个值就大到离谱了）。

那么我们怎么知道需要多大才能「一定不会被取到」那？**这就需要认真看题目的要求了**。

题目要求是 ： `k` 是在 `[0,10^9]` 区间的整数，也就是说，`trailingZeroes(n)` 的结果最大可以达到 `10^9`。

然后我们可以反推，当 `trailingZeroes(n)` 的结果为 `10^9` 时，`n` 为多少？这个不需要你精确计算出来，你只要找到一个数 `hi`,使得 `trailingZeroes(hi)` 比 `10^9` 大，就可以把 `hi` 当做正无穷，作为搜索区间的上限。

刚才说了 `trailingZeroes` 函数时单调函数，那么我们就可以猜，先算一下 `trailingZeroes(INT_MAX)` 的结果， 比`10^9` 小一些，再用 `LONG_MAX` 算一下，远超 `10^9`了，所以 `LONG_MAX` 可以作为搜索的上界。

这里为了避免整形溢出，把 `trailingZeroes` 函数把所有的数据类型都改成 long

现在明确了问题：

**在区间 [0,LONG_MAX] 中寻找满足 `trailingZeroes(n) == k`的左侧边界和右侧边界。**






