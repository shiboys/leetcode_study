## 双指针解决链表相关 7 道题目

数组中没有真正意义的指针，但是我们可以把索引当做数组的指针，这样也可以在数组中实战双指针技巧，**本章节主要讲数组相关的双指针算法**

### 快慢指针技巧

**数组问题中比较常见的快慢指针技巧，是让你原地修改数组**

比如 leetcode 第 26 题「删除有序数组中的重复项」，让你在有序数组中去重：

![有序数组去重](../algorithm/dynamic_programming/imgs/array1.png)

函数签名如下：
```java
int removeDuplicates(int[] nums);
```

#### 数组原地删除元素 

leetcode 第 27 题，题目描述如下所示：

![数组原地删除](../algorithm/dynamic_programming/imgs/array2.png)

题目要求我们把 `nums` 中的所有值为 `val` 的元素原地删除，依然需要使用快慢指针技巧：

如果 `fast` 遇到值为 `val` 的元素，则直接跳过，否则就赋值给 `slow` 指针，并让 `slow` 前进一步。

这几本和前面说到了数组去重问题解法思路是完全一样的。直接上代码，参考removeElement()

#### 移动零

leetcode 第 283 题

给你输入一个数组 `nums`, 请你**原地修改**, 将数组中的所有值为 0 的元素移动到末尾，函数签名如下：

```java
void moveZeros(int[] nums);
```
这道题让我们将所有的 0 移动到最后，其实就相当于移除 `nums` 中的所有 0，然后再把后面的元素都复制为 0 即可。

___

到这里，原理修改数组的这些图姆就已经差不多了。数组中另一大类快慢指针的题目就是「滑动窗口算法」。滑动窗口算法会有一个专门的章节来讲解

### 左右指针的常用算法

#### 1、二分查找

二分查找会有一个专门的章节详细探讨二分搜索的细节问题，我们这里只写最简单的二分算法，旨在突出它的双指针特性.

#### 2、两数之和

![数组原地删除](../algorithm/dynamic_programming/imgs/array3.png)

**只要数组有序**，就应该想到双指针技巧。这道题的解法有点类似二分查找，通过调整 `left` 和 `right` 就可以调整 `sum` 的大小：

#### 3、 反转数组

一般编程语言都会提供 `reverse` 函数，其实这个函数的原理非常简单，leetcode 第 344 题，「反转字符串」就是类似需求，让你反转一个 `char[]` 类型的字符数组，函数签名为 `void reverseString(char[] s)`

#### 4、回文判断

首先明确一下，回文串就是正着读和反着读都一样的字符串。

比如说字符串 `aba` 和 `abba` 都是回文串，因为他们对称，反过来还是和本身一样；反之，字符串 `abac` 就不是回文串。

我们现在你应该感觉到回文串问题和左右指针肯定有密切的联系，比如让你判断一个字符串是不是回文串，我们就可以写出代码，参见 isPalindrome(String s)。
我们把强度提升下，leetcode 第 5 题，判断「最长回文子串」

![最长回文子串](../algorithm/dynamic_programming/imgs/array4.png)

函数签名如下：
```java
String longestPalindrome(String s);
```

找回文的难点在于，回文串的长度可能是奇数也可能是偶数，**解决该问题的核心是从中心向两端扩散的双指针技巧**。

如果回文串的长度为奇数，则它有一个中心字符串；如果回文串的长度为偶数，则可以认为它有两个中心字符串。我们可以先实现一个获取回文的方法
```java
String palindromeString(String s,int i, int j) {
    while(i>=0 && j <= s.length()-1 &&
            s.charAt(i) == s.charAt(j)) {
                i--;
                j++;
    }
    return s.substring(i+1,j);
}
```

### 前缀和

#### 二维矩阵的前缀和

![最长回文子串](../algorithm/dynamic_programming/imgs/matrix_pre_sum.png)

注意看这幅图，任意子矩阵的元素都可以转化成它周边几个大矩阵的元素和的运算

而这四大矩阵有一个共同的特点，就是左上角都是(0,0)原点。

我们维护一个 preSum 数组，专门记录以原点为顶点的矩阵的元素之和，就可以用几次加减运算出任何一个子矩阵的元素和。

代码如 sumRegion 方法

### 小而美的算法技巧：差分数组

**「前缀和」主要的使用场景是原始数组不会被修改的情况下，频繁查询某个区间的累加和**。
差分数组和前缀和的思想非常相似的算法技巧，**差分数组的主要适用场景是频繁对原始数组的某个区间的元素进行增减**。
比如说，我给你输入一个数组 `nums`, 然后又要求给区间 `nums[2..6]` 全部加上 1，再给 `nums[3..9]` 全部减 3，再给 `nums[0..4]` 全部加 2，再给...。一顿操作猛如虎，最后问你，`nums` 数组的值是什么？

常规思路就是操作哪个区间，就在哪个区间加一个 for 循环呗，还能咋样？这种思路的时间复杂度是 O(N), 由于这个场景下对 `nums` 的修改非常频繁，所以效率会非常低下。

这里就需要用到查分数组，类似「前缀和」的构造技巧 `preSum` 数组，我们先对 `nums` 数组构造一个查分数组 `diff`, `diff[i]` 就是 `nums[i]` 和 `nums[i-1]` 之差。

**最牛逼的地方来了，通过这个 `diff` 查分数组可以反推出原始数组 `nums` 的**

**这样构造查分数组 `diff` ，就业快速进行区间增减的操作**，如果我们想对区间 `nums[i..j]` 的元素全部加 3，那么只要让 `diff[i] +=3`, 然后再让 `diff[j+1] -=3 ` 即可：

原理很简单，diff[i] +=3 意味着给 nums[i..] 的所有元素都加了 3，diff[j+1] -=3 又意味着对 nums[j+1..] 再减 3，综合起来就是对 `nums[i..j]` 中的所有元素都加 3 了。

只要花费 O(1) 的时间，修改 `diff` 数组，就相当于给 `nums` 的整个区间做了修改。多次修改 `diff`, 然后通过 `diff` 数组反推，即可得到 `nums` 修改后的结果

#### 算法实践

leetcode 370 题，「区间加法」直接考察了差分数组的技巧。

![差分数组](../algorithm/dynamic_programming/imgs/different_array.png)

实现方法参加 Different 类

然而，实际上的算法可能需要我们对题目进行联想和抽此昂，不会那么直接地让我们看出来要用差分数组技巧，这里看一下 leetcode 1109 题「航班预订统计」：

![差分数组](../algorithm/dynamic_programming/imgs/different_array2.png)

解释如下：
```text
Input: bookings = [[1,2,10],[2,3,20],[2,5,25]], n = 5
Output: [10,55,45,25,25]
Explanation:
Flight labels:        1   2   3   4   5
Booking 1 reserved:  10  10
Booking 2 reserved:      20  20
Booking 3 reserved:      25  25  25  25
Total seats:         10  55  45  25  25
Hence, answer = [10,55,45,25,25]
```

这道题就是在那绕弯弯，其实它就是个差分数组，我们这里给翻译一下：
给你输入一个长度为 `n` 的数组 `nums`,其中所有元素都是0。再给你输入一个 `bookings`, 里面是若干三元组 `(i,j,k)`，每个三元组的含义就是要求你给 `nums` 数组的闭区间 `[i-1,j-1]` 中的所有元素都加上 `k`。请你返回最后的 `nums` 数组是多少？

这么一看，不就是一道标准的差分数组题嘛？我们可以直接复用 Different 类。

还有一道很类似的题目，leetcode 1094 题 「拼车」，这里简单描述下：

你是一个公交车司机，公交车的最大载客量为 `capacity`, 沿途要经过若干站，给你一份乘客行程表 `int[][] trips`, 其中 `trips[i] = [num,start,end]` 代表着有 `nums` 个旅客要从站点 `start` 上车，到站点 `end` 下车，请你计算是否能够一次把所有旅客运送完毕（不能超过最大载客量 `capacity`）。
函数签名如下：

```java
boolean canPooling(int[][] trips, int capacity);
```
比如输入：
```python
trips = [[2,1,5],[3,3,7]], capacity=4
```
就不能一次运完，因为 `trips[1]` 最多只能上 2 人，否则车就会超载。

相信我们大家已经联想到差分数组技巧了，**`trips[i]` 代表着一组空间操作，旅客的上下车就相当于数组区间的加减；只要结果数组中的元素都小于 `capacity` ，就说明可以不超载云诉讼素有的旅客**。

但问题是，差分数组的长度(车站的个数)应该是多少？题目没有值直接给出，但给出了数据取值范围：
```java
0 <= fromi < toi <= 1000
```
车站编号从 0 开始，最多到 1000，也就是最多有 1001  个车站，那么我们的差分数组长度可以直接设为 1001 ，这样索引刚好可以覆盖所有的车站编号：
参考 canPooling 

### 二维数组的花式遍历

框架可以解决大部分有套路可循的题目。

但是框架思维也不是万能的，有一些特定的技巧，属于会者不难，难者不会的类型，只能通过多刷题进行总结和积累。

本章节分享一些巧妙的二维数组的花式操作，这里我们有个印象，以后遇到此类题目就不会懵圈了。

#### 顺/逆时针旋转矩阵

对二维数组进行旋转是常见的笔试题，力扣第 48 题「旋转图像」就是很经典的一道：

![差分数组](../algorithm/dynamic_programming/imgs/rotate_matrix.png)

题目很好理解，就是让你将一个二维矩阵顺时针旋转 90 度，**难点在于「原地」修改**，函数签名如下：
```java
void rotate(int[][] matrix);
```
如何「原地」旋转二维数组？稍微想一下，感觉操作起来非常复杂，可能要设置巧妙的算法机制来「一圈一圈」旋转矩阵：

**但实际上，这道题不能走寻常路**，在详细描述这道题的解法之前，我们先看另一道谷歌曾经考过的算法题热热身：
给你一个包含若干单词的空格的字符串 `s`, 请你写一个算法，**原地**反转所有单词的顺序。 比如给你输入一个这样的字符串：

```java
s="hello world java"
```
你的算法需要**原地**反转这个字符串中的单词顺序
```java
s="java world hello"
```

常规的方式是把 `s` 按空格 `split` 成若干单词，然后 `reverse` 这些单词的顺序，最后再把这些单词 `join` 成句子。但是这种方式使用了额外的空间，并不是「元地反转」单词。

**正确的做法是，湘江啊整个字符串 `s` 反转**：

```java
s = "avaj dlrow olleh"
```
**然后再将每个单词反转**

```java
s="java world hello"
```
这样，就实现了原地反转所有单词顺序的目的。leetcode 第 151 题 「颠倒字符串中的单词」就是类似的问题，我们会尝试去解决一下

这里提这道题的目的是什么那？

**旨在说明，有时候我们拍脑袋的常规思维，在计算机看来可能并不是最优雅的；但是计算机觉得最优雅的思维，对我们来说却不是那么直观**。这也许就是算法的魅力所在吧。

回到之前说的顺时针旋转二维矩阵的问题，常规的思路就是去寻找原始坐标和旋转后做的映射规律，但我们是否可以让思维跳跃一下，尝试把矩阵进行反转，镜像对称等操作，可能会出现新的突破口。

![矩阵反转1](../algorithm/dynamic_programming/imgs/rotate_matrix_1.png)

**然后在对矩阵的每一行进行反转**:
![矩阵反转1](../algorithm/dynamic_programming/imgs/rotate_matrix_3.png)

发现结果就是 `matrix ` 顺时针旋转 90 度的结果，将上述思想翻译成代码，即可解决本问题

#### 矩阵的螺旋遍历

leetcode 第 54 题，螺旋矩阵

![螺旋遍历矩阵](../algorithm/dynamic_programming/imgs/traverse_matrix_title2.png)

该函数的签名如下：

```java
List<Integer> spiralOrder(int[][] matrix);
```

**解题的核心思路是按照右、下、左、上的顺序遍历数组，并用四个变量圈定未遍历元素的边界**：

![螺旋遍历矩阵](../algorithm/dynamic_programming/imgs/traverse_matrix_6.png)

随着螺旋遍历，相应的边界会收缩，知道螺旋遍历完整个数组，根据这个思路，我们写出代码就比较容易了。


#### 旋转矩阵 II

leetcode 第 59 题，也是类似的题目，只不过是反过来，让你按照螺旋的顺序生成矩阵：

![螺旋遍历矩阵](../algorithm/dynamic_programming/imgs/spiral_matrix_2.png)

函数签名为 `int[][] generateMatrix(int n)`

有了上面的铺垫，稍微改一下代码即可完成这道题

### 滑动窗口算法，改编成一首诗

这里抄阿东的一首小诗来歌颂滑动窗口的伟大。
        滑动窗口防滑记      
链表子串数组题，用双指针别犹豫。
双指针家三兄弟，个个都是万人迷。

**快慢指针**最神奇，链表操作无压力。
归并排序找中点，链表成环搞判定。

**左右指针**最常见，左右两端相向行。
反转数组要靠它，二分搜索是弟弟。

**滑动窗口**老猛男，子串问题全靠它。
左右指针划窗口，一前一后齐并进。

自诩十年老司机，怎料农村道路滑。
一不小心滑到了，鼻青脸肿少颗牙。
算法思想很简单， 出了 bug 想升天。

关于双指针的快慢指针和左右指针用法，之前的例子已经不少了，本章节解决一类最难掌握的技巧：滑动窗口技巧。总结出一套框架，熟练掌握之后，可以闭着眼写出正确的解法。

滑动窗口的算法思想很简单，就是维护一个窗口，不断滑动，然后更新答案。 leetcode 上面起码有 10 道题运用滑动窗口算法，难度都是中等和困难。该算法的大致逻辑如下：

```java
int left =0,right =0;
while(left < right && right < s.length()) {
    //增大窗口
    window.add(s[right]);
    right++;
    
    while(window should shrink) {
        // 缩小窗口
        window.remove(s[left]);
        left++;
    }
}
```
这个算法的时间复杂度是 O(N), 比字符串暴力算法要高效的多。

其实困扰我们大家的不是思路问题，而是各种细节问题。比如合适添加元素，如何缩小窗口，在窗口滑动的哪个阶段更新结果。即便你明白这些细节，也容易出现 Bug，bug 还不容易找到，挺让人烦的。

**今天本章节总结出一套框架，以后遇到相关问题，直接套框架，基本就可以解决问题了**

#### 最小覆盖子串

leetcode 第 76 题，描述如下：
![最小覆盖子串](../algorithm/dynamic_programming/imgs/sliding_window_.png)

就是说要在 `S`(source)中找到包含 `T(target)` 中全部字母的一个子串，且这个子串一定是所有可能子串中最短的。

暴力解法大概是这样的
```java
for(int i=0;i<s.length();i++) {
    for(j=i+1;j<s.length();j++) {
        if s[i:j] 包含 t 中所有的字母:
            更新答案
    }
}
```
思路很简单，但是显然，这个算法的复杂度肯定大于 O(N^2) 了，不好。

下面结合步骤图来理解一下，`needs` 和 `windows` 相当于计数器，分别记录 `T` 中字母出现次数 和 「窗口」中的相应字符出现次数。

初始状态：

![滑动窗口图文解释](../algorithm/dynamic_programming/imgs/sliding_window1.png)

增加 `right` ,直到窗口 `[left,right)` 包含了 `T` 中所有字符。

![滑动窗口图文解释](../algorithm/dynamic_programming/imgs/sliding_window2.png)

现在开始缩小窗口`[left, right)`，增加 `keft`:

![滑动窗口图文解释](../algorithm/dynamic_programming/imgs/sliding_window3.png)

直到窗口中的字符串不再符合要求，`left` 就不再继续移动

![滑动窗口图文解释](../algorithm/dynamic_programming/imgs/sliding_window4.png)

之后重复上述过程，先移动 `right`，在移动 `left`... 直到 `right` 指针到达字符串 `S` 的末端，算法结束。

接下里请参考代码 SlidingWindow.java

#### 字符串排列

leetcode 第 567 题，字符串的排列

![leetcode 567 题，字符串的排列](../algorithm/dynamic_programming/imgs/sliding_window_title2.png)

注意哦，输入的 s1 是可以包含重复字符的，所以这个题难度不小

这种题目，是明显的滑动窗口算法，**相当于给你一个 `S` 和一个 `T`，请问你 `S` 中是否存在一个子串，包含`T` 中素有的字符切不包含其他字符？**

这道题的解法几乎跟最小覆盖一模一样。主需要改几个地方：
1、移动 left 缩小窗口的时机是窗口大于等于 t.size()，因为排列(是子串，不是子序列)嘛，显然长度应该是一样的。
2、当发现 `valid == need.size()` 时，就说明窗口中是一个合法的排列，所以应该立即返回 true

至于其他的处理窗口的扩大和缩小，和最小覆盖子串完全相同。

#### 查找所有字母异位词

leetcode 438 题，「查找字符串中所有字母异位词」，描述如下
![leetcode 428 题，查找以为此](../algorithm/dynamic_programming/imgs/sliding_window_title3.png)

这里的字母异位词，不就是排列嘛，整个高端的说法就能糊弄人？**相当于，输入一个串 `S`, 一个串 `T`，找到 S 中所有的 T 的排列，并返回他们的起始索引**。

详见 findAnagrams 方法。


#### 无重复字符的最长子串

leetcode 第 3 题
![leetcode 第 3 题，无重复字符的最长子串](../algorithm/dynamic_programming/imgs/sliding_window_title4.png)

这道题我之前做过，不过应该不是用滑动窗口的，这里使用滑动窗口重做一版

