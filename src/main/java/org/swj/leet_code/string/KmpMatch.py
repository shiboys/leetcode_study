"""
使用 Python 实现的 kmp 算法
kmp 算法，是 Knuth-Morris-Pratt 三个学者(大佬)的首字母缩写。
既然在比对失败的时候，我们已经知道了之前读过哪些字符串，有没有可能避免原始字符串“调回下一个字符”
于是他们就发表了 线性复杂度的 KMP 算法
其基本思路是当我们发现某个字符不匹配的时候，由于已经知道之前已经遍历过的字符，那能不能利用这些信息来避免暴力"回退(backup)" 的步骤那？
换句话说，我们永远不回退 i 指针，而是利用已经遍历过的信息，把 j 指针移动到正确的位置，继续匹配。如果能够做到这一点，我们的算法就可以
改进为线性复杂度了
举个栗子
主串： ABABABCAA
子串： ABABC

我们搜索 ABABC 这个子串的时候，发现最后一个字符不匹配，这个时候由于我们已经知道前面读过哪些字符，是否可以将子串往后移动到__ABBAC 的位置,
接着进行匹配，由于子串中的 AB 和主串中的 AB 是匹配的，我们可以完全跳过他们，避免重复比对，接下来只需要测试后面的字符就好了
我们可能会问，怎么知道跳过多少个字符那？这里就要用到 KMP 算法中定义到的 next 数组了，如下所示，我们先不管 next 数组是如何生成的

子串： ABABC
next  00120

先来看下它的功能和用途，KMP 算法在匹配失败的时候，会去看最后一个匹配失败的字符它所对应的 next 数组中的值，比如这里 C 匹配失败，next[C-1] = 2
于是我们移动子串，将 C 对应的 2 个字符往后移动，这里的 2 代表子串中可以“跳过匹配”的字符个数，也就是 input 的前面的两个字符 AB 不需要看了
这是因为跳过的两个 AB 之后，剩下的两个字符 AB 和主串中的 AB 依然是匹配的，于是我们只需要比对后面的字符就好了。
由于不在需要回退主串中的指针，只需要一次主串的遍历就可以完成匹配，效率自然就会比暴力算法高很多

"""


def kmp_match(input: str, match: str):
    # 计算 next 数组
    next = getNext(match)
    i = 0
    j = 0
    while i < len(input) and j < len(match):
        if (input[i] == match[j]):  # 逐个字符比较，如果相等，则递增 i 和 j 两个指针，
            i = i + 1
            j = j + 1
        elif j > 0:  # 字符匹配失败，并且 j 大于 0，则 j 指针后移
            j = next[j - 1]  # 往后退 next[j-1] 步骤，跳过一些不必要的匹配步骤
        else:
            i = i + 1  # 此时 j=0，表示第一个字符就匹配失败，也就是没有当前字符 match[j] 没有跟 input 中的任何字符可匹配, i 只向前移动

    if (j == len(match)):  # 匹配成功，j 到达匹配的末尾
        return i - j
    return -1


# kmp 的 next 数组，元素的值是 match 字符串中每个字符的最长前后缀匹配的长度
def getNext(match: str):
    # Python 的数组如果采用固定大小的方式，就是 next = [0]*len(match) 的方式，这样就能使用 next[i] = xx 了
    # next 数组的本质就是寻找前后缀相同前后缀字符串的长度，且是最长的前后缀子串的长度，比如匹配串 ABACABA,那最后一个 A 的 next 值就是 3
    # 另外我们要找的前后缀不能是字符串本身，比如我们总共 ABAB 4 个字符，那如果跳过前 4 个字符比较还有意义吗？
    # 比如字符串 ABABC，开头的 A 字符的 next 值就是 0，因为 A 字符前面没有字符串了，B 字符，以B字符结尾的子串没有相同的前后缀, 所以 next 为0
    # 第三个字符 A，由于是共同的前后缀，所以 next 为 1，对于前 4 个字符，由于 AB 是共同的前后缀，第二个 B 字符的 next 为 2
    # 第 5 个字符，没有相同的前后缀，所以第 5 个字符的 next 值为 0。到此我们就得到了整个 next 数组
    # 但是算法应该怎么写那？for 循环暴力求解，效率太低，我们可以采用一种递推的方式来快速求解，它的巧妙之处就在于会不断利用已经掌握的信息
    # 来避免重复的运算，比如字符 ABxxABxx, 接下来分两种情况讨论，第一种情况，如果下一个字符依然相同的话，比如 ABAxABAx 不就构成了一个更长的前后缀了吗
    # 很明显，最后一个 A 的 next 长度等于之前的长度 + 1，next 就是 [0,0,1,x,1,2,3,x]。但是如果下一个字符不相同那？比如 ABACABAB
    # 既然 ABA 无法与下一个字符构成更长的前后缀，我们就退而求其次，看看其中是否存在更短的，比如倒数第一个 A，它其实是有可能跟下一个字符构成更长的共同前后缀的
    # 这一步难道要暴力求解吗？其实不然，根据之前的计算，我们掌握了一个重要的信息第二个 ABA 跟第一个 ABA 是相同的，那我们直接在第一个 ABA 中寻找相同的字符就行，
    # 为什么跟第一个 ABA 比对？因为我们要求共同的前后缀，当然得是第一个相同的字符串开始了。第一个 ABA 的最后一个 A 的 next 值是 1，
    # 此时回到最开始的步骤，检查下一个字符是否相同，此时 前缀的 B 跟当前的 B 相同，则可以构成一个更长的前后缀，长度+1 即可

    #next = [0]  # 初始值为 0
    next = [0] * len(match)
    # i 来扫描当前匹配串
    i = 1
    # prefix_len 代表前后缀匹配的最长字符串的长度
    prefix_len = 0
    while i < len(match):
        if match[i] == match[prefix_len]:  # 下一个字符相同，表示可以构成一个更长的前后缀，长度+1
            prefix_len = prefix_len + 1
            # 元素是前后缀相同子串的长度。append 方法类似于 java 中  ArrayList 的 add 方法。python 的数组会自动扩容
            # 填充 next 数组
            # next.append(prefix_len)
            next[i] = prefix_len
            i = i + 1
        elif prefix_len > 0:
            # 如果下一个字符不相同，但是 prefix_len 大于 0，我们直接查表看看其中是否存在更短的的前后缀
            # prefix_len 此时需要跳转到 next[prefixl_len-1] 的位置，继续判断前后缀的最长子串的长度
            prefix_len = next[prefix_len - 1]
        else:
            # 没有匹配，i 往前移动一位，next 数组填充 0
            #next.append(0)
            next[i] = 0
            i = i + 1

    return next


if __name__ == "__main__":
    input = "作为程序员一定学习编程之道，一定要对代码的编写有追求，不能实现就完事了。我们应该让自己写的代码更加优雅，即使这会费时费力"
    match = "不能实现就完事了"
    res = kmp_match(input, match)
    res2 = input.index(match)
    next = getNext("ABCABCDABCD")
    print("next is ", next)
    # 结果是两者相等，kmp 在 input 和 match 都是超大量文本匹配的时候，性能非常突出
    # 一般变成语言内置的 index 算法都是使用暴力匹配的，复杂度是 O(m*n)
    print("kmp_match is ", res, " and python builtin index is ", res2)

"""
总结，next 数组的计算确实比较绕，但它的本质是通过已经掌握的信息来避免重复的运算，这和动态规划的思想是一样的
"""